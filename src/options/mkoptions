#!/bin/bash
#
# mkoptions
# Morgan Deters <mdeters@cs.nyu.edu> for CVC4
# Copyright (c) 2011  The CVC4 Project
#
# The purpose of this script is to create options.{h,cpp}
# from template files and a list of options.
#
# Invocation:
#
#   mkoptions template-file output-file options-files...
#

copyright=2011

filename=`basename "$1" | sed 's,_template,,'`

me=$(basename "$0")

template=$1; shift
output=$1; shift

cat >"$output" <<EOF
/*********************                                                        */
/** $filename
 **
 ** Copyright $copyright  The AcSys Group, New York University, and as below.
 **
 ** This file automatically generated by:
 **
 **     $0 $@
 **
 ** for the CVC4 project.
 **/

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* $1 */

EOF

module_id=
module_name=
module_includes=
module_defaults=
module_optionholder_spec=
module_decls=
module_specializations=
module_accessors=
module_short_options=
module_long_options=
module_option_handlers=
include_all_option_headers=
all_modules_contributions=
option_handler_includes=

seen_module=false
seen_endmodule=false
expect_doc=false
expect_doc_alternate=false
n_long=256

internal=
smtname=
short_option=
short_option_alternate=
long_option=
long_option_alternate=
long_option_alternate_set=
type=
predicates=

function module {
  # module id name

  seen_module=true
  if [ $# -lt 2 -o -z "$1" -o -z "$2" ]; then
    echo "$kf:$lineno: error: \"module\" directive requires exactly two arguments" >&2
    exit 1
  fi

  module_id="$1"; shift
  module_name="$@"
  include_all_option_headers="${include_all_option_headers}
#include \"$kf.h\""
  all_modules_contributions="${all_modules_contributions}
  ${module_id}_OPTIONS"
  module_optionholder_spec="#define ${module_id}_OPTIONS"
}

function endmodule {
  # endmodule
  check_module_seen
  check_doc
  seen_endmodule=true
  if [ $# -ne 0 ]; then
    echo "$kf:$lineno: error: endmodule takes no arguments" >&2
    exit 1
  fi
}

function common-option {
  # common-option option-args...
  handle_option COMMON "$@"
}

function option {
  # option option-args...
  handle_option STANDARD "$@"
}

function expert-option {
  # expert-option option-args...
  handle_option EXPERT "$@"
}

function undocumented-option {
  # undocumented-option option-args...
  handle_option UNDOCUMENTED "$@"
}

function handle_option {
  check_module_seen
  check_doc

  args=("$@")

  category="${args[0]}"
  internal="${args[1]}"
  smtname=
  short_option=
  short_option_alternate=
  long_option=
  long_option_alternate=
  long_option_alternate_set=
  type=
  predicates=
  readOnly=true
  required_argument=false
  default_value=
  handlers=
  links=
  links_alternate=

  if [ "$category" = UNDOCUMENTED ]; then
    expect_doc=false
  else
    expect_doc=true
  fi
  expect_doc_alternate=false

  # scan ahead to see where the type is
  type_pos=2
  while [ $(($type_pos+1)) -lt ${#args[@]} ] && ! expr "${args[$(($type_pos+1))]}" : ":" &>/dev/null; do
    let ++type_pos
  done

  type="${args[$type_pos]}"

  if [ "$type" = argument ]; then
    type=void
    required_argument=true
  fi

  if [ $type_pos -eq 2 ]; then
    expect_doc=false
    readOnly=false
  else
    i=2
    while [ $i -lt $type_pos ]; do
      if expr "${args[$i]}" : '--' &>/dev/null || expr "${args[$i]}" : '/--' &>/dev/null; then
        if [ -n "$long_option" -o -n "$long_option_alternate" ]; then
          echo "$kf:$lineno: error: malformed option line for \`$internal': unexpected \`${args[$i]}'" >&2
          exit 1
        fi
        long_option="$(echo "${args[$i]}" | sed 's,/.*,,')"
        if [ -n "$long_option" ]; then
          if ! expr "$long_option" : '--.' &>/dev/null; then
            echo "$kf:$option: bad long option \`$long_option': expected something like \`--foo'" >&2
            exit 1
          fi
          long_option="$(echo "$long_option" | sed 's,^--,,')"
        fi
        if expr "${args[$i]}" : '.*/' &>/dev/null; then
          long_option_alternate="$(echo "${args[$i]}" | sed 's,[^/]*/,,')"
          long_option_alternate_set=set
          if [ -n "$long_option_alternate" ]; then
            if ! expr "$long_option_alternate" : '--.' &>/dev/null; then
              echo "$kf:$option: bad alternate long option \`$long_option_alternate': expected something like \`--foo'" >&2
              exit 1
            fi
            long_option_alternate="$(echo "$long_option_alternate" | sed 's,^--,,')"
          fi
        fi
      elif expr "${args[$i]}" : '-' &>/dev/null || expr "${args[$i]}" : '/-' &>/dev/null; then
        if [ -n "$short_option" -o -n "$short_option_alternate" -o -n "$long_option" -o -n "$long_option_alternate" ]; then
          echo "$kf:$lineno: error: malformed option line for \`$internal': unexpected \`${args[$i]}'" >&2
          exit 1
        fi
        short_option="$(echo "${args[$i]}" | sed 's,/.*,,')"
        if [ -n "$short_option" ]; then
          if ! expr "$short_option" : '-.$' &>/dev/null; then
            echo "$kf:$option: bad short option \`$short_option': expected something like \`-x'" >&2
            exit 1
          fi
          short_option="$(echo "$short_option" | sed 's,^-,,')"
        fi
        if expr "${args[$i]}" : '.*/' &>/dev/null; then
          short_option_alternate="$(echo "${args[$i]}" | sed 's,[^/]*/,,')"
          if expr "$short_option_alternate" : - &>/dev/null; then
            if ! expr "$short_option_alternate" : '-.$' &>/dev/null; then
              echo "$kf:$option: bad alternate short option \`$short_option_alternate': expected something like \`-x'" >&2
              exit 1
            fi
            short_option_alternate="$(echo "$short_option_alternate" | sed 's,^-,,')"
          fi
        fi
      else
        if [ -n "$smtname" -o -n "$short_option" -o -n "$short_option_alternate" -o -n "$long_option" -o -n "$long_option_alternate" ]; then
          echo "$kf:$lineno: error: malformed option line for \`$internal': unexpected \`${args[$i]}'" >&2
          exit 1
        fi
        smtname="${args[$i]}"
      fi
      let ++i
    done
  fi

  if [ "$type" = void -a "$internal" != - ]; then
    echo "$kf:$lineno: error: $internal cannot be void-typed; use \`-' as the name if its to be void" >&2
    exit 1
  elif [ "$type" != void -a "$internal" = - ]; then
    echo "$kf:$lineno: error: cannot use an unnamed option if its type is not void" >&2
    exit 1
  fi

  if [ "$type" = bool -a -n "$long_option" -a -z "$long_option_alternate" -a -z "$long_option_alternate_set" ]; then
    long_option_alternate="no-$(echo "$long_option" | sed 's,^--,,')"
  fi
  if [ "$type" != bool -a -n "$short_option_alternate" ]; then
    echo "$kf:$lineno: error: cannot use alternate short option $short_option_alternate for \`$internal' because it's not of bool type" >&2
    exit 1
  elif [ "$type" != bool -a -n "$long_option_alternate" ]; then
    echo "$kf:$lineno: error: cannot use alternate long option $long_option_alternate for \`$internal' because it's not of bool type" >&2
    exit 1
  fi

  # parse attributes
  i=$(($type_pos+1))
  while [ $i -lt ${#args[@]} ]; do
    attribute="${args[$i]}"
    case "$attribute" in
    :default)
       let ++i
       default_value="${args[$i]}"
       ;;
    :handler)
       while [ $(($i+1)) -lt ${#args[@]} ] && ! expr "${args[$(($i+1))]}" : ":" &>/dev/null; do
         let ++i
         handlers="${handlers} ${args[$i]}"
       done
       ;;
    :link)
       while [ $(($i+1)) -lt ${#args[@]} ] && ! expr "${args[$(($i+1))]}" : ":" &>/dev/null; do
         let ++i
         link="${args[$i]}"
         if expr "${args[$i]}" : '.*/' &>/dev/null; then
           links="${links} $(echo "${args[$i]}" | sed 's,/.*,,')"
           links_alternate="${links_alternate} $(echo "${args[$i]}" | sed 's,[^/]*/,,')"
         else
           links="${links} ${args[$i]}"
           links_alternate="${links_alternate} ${args[$i]}"
         fi
       done
       ;;
    :include)
       while [ $(($i+1)) -lt ${#args[@]} ] && ! expr "${args[$(($i+1))]}" : ":" &>/dev/null; do
         let ++i
         module_includes="${module_includes}
#include \"${args[$i]}\""
       done
       ;;
    :handler-include)
       while [ $(($i+1)) -lt ${#args[@]} ] && ! expr "${args[$(($i+1))]}" : ":" &>/dev/null; do
         let ++i
         option_handler_includes="${option_handler_includes}
#include \"${args[$i]}\""
       done
       ;;
    :read-write)
       readOnly=false
       ;;
    :read-only)
       readOnly=true
       ;;
    *)
       echo "$kf:$lineno: error in option \`$internal': bad attribute \`$attribute'" >&2
       exit 1
    esac
    let ++i
  done

  # set up structures
  if [ "$internal" != - ]; then
    # set up a field in the options_holder
    module_optionholder_spec="${module_optionholder_spec} \\
  ${internal}_t::type $internal;"
    module_decls="${module_decls}
extern struct ${internal}_t { typedef $type type; } $internal;"
    module_defaults="${module_defaults:+${module_defaults},}
  $internal($default_value)"

    if ! $readOnly; then
      module_specializations="${module_specializations}
template <> void Options::set(${internal}_t, const ${internal}_t::type& x);"
      module_accessors="${module_accessors}
template <> void Options::set(${internal}_t, const ${internal}_t::type& x) {
  d_holder->$internal = x;
}"
    fi
    module_specializations="${module_specializations}
template <> const ${internal}_t::type& Options::operator[](${internal}_t) const;"
    module_accessors="${module_accessors}
template <> const ${internal}_t::type& Options::operator[](${internal}_t) const {
  return d_holder->$internal;
}"
  fi

  if $required_argument || [ "$type" != bool -a "$type" != void ]; then
    expect_arg=:
    expect_arg_long=required_argument
  else
    expect_arg=
    expect_arg_long=no_argument
  fi
  cases=
  cases_alternate=
  if [ -n "$short_option" ]; then
    module_short_options="${module_short_options}$short_option$expect_arg"
    cases="${cases}
    case '$short_option':"
  fi
  if [ -n "$short_option_alternate" ]; then
    module_short_options="${module_short_options}$short_option_alternate$expect_arg"
    cases_alternate="${cases_alternate}
    case '$short_option_alternate':"
  fi
  if [ -n "$long_option" ]; then
    module_long_options="${module_long_options}
  { \"$(echo "$long_option" | sed 's,=.*,,')\", $expect_arg_long, NULL, $n_long },"
    cases="${cases}
    case $n_long:// --$long_option"
    let ++n_long
  fi
  if [ -n "$long_option_alternate" ]; then
    module_long_options="${module_long_options}
  { \"$(echo "$long_option_alternate" | sed 's,=.*,,')\", $expect_arg_long, NULL, $n_long },"
    cases_alternate="${cases_alternate}
    case $n_long:// --$long_option_alternate"
    let ++n_long
  fi
  run_links=
  run_links_alternate=
  if [ -n "$links" ]; then
    for link in $links; do
      run_links="$run_links
      preemptGetopt(extra_argc, extra_argv, \"$link\");"
    done
  fi
  if [ -n "$links_alternate" ]; then
    for link in $links_alternate; do
      run_links_alternate="$run_links_alternate
      preemptGetopt(extra_argc, extra_argv, \"$link\");"
    done
  fi
  if [ -n "$cases" ]; then
    if [ "$type" = bool ]; then
      module_option_handlers="${module_option_handlers}${cases}
      runBoolHandlers($internal, *this, argv[optind], true);
      d_holder->$internal = true;$run_links
      break;
"
    elif [ -n "$expect_arg" -a "$internal" != - ]; then
      module_option_handlers="${module_option_handlers}${cases}
      d_holder->$internal = runHandlers($internal, *this, argv[optind - 1], optarg);$run_links
      break;
"
    elif [ -n "$expect_arg" ]; then
      run_handlers=
      for handler in $handlers; do
        run_handlers="$run_handlers
      $handler(*this, optarg);"
      done
      module_option_handlers="${module_option_handlers}${cases}
      $run_handlers$run_links
      break;
"
    else
      run_handlers=
      for handler in $handlers; do
        run_handlers="$run_handlers
      $handler(*this);"
      done
      module_option_handlers="${module_option_handlers}${cases}
      $run_handlers$run_links
      break;
"
    fi
  fi
  if [ -n "$cases_alternate" ]; then
    if [ "$type" = bool ]; then
      module_option_handlers="${module_option_handlers}${cases_alternate}
      runBoolHandlers($internal, *this, argv[optind], false);
      d_holder->$internal = false;$run_links_alternate
      break;
"
    else
      echo "$kf:$lineno: internal error: expected BOOL-typed option in alternate handler" >&2
      exit 1
    fi
  fi

}

function alias {
  # alias (smtname | -option) = (smtname [arg] | -option [arg])+
  check_module_seen
  check_doc

  echo "$kf:$lineno: error: alias not yet supported" >&2
  exit 1
}

function doc {
  # doc text...
  check_module_seen
  expect_doc=false

  if [ -z "$short_option" -a -z "$long_option" ]; then
    if [ -n "$short_option_alternate" -o -n "$long_option_alternate" ]; then
      if [ -n "$smtname" ]; then
        expect_doc_alternate=true
      else
        doc-alternate "$@"
        return
      fi
    fi
  fi

  # do doc
}

function doc-alternate {
  # doc-alternate text...
  check_module_seen
  expect_doc_alternate=false

  if $expect_doc; then
    echo "$kf:$lineno: error: must provide documentation before alternate documentation" >&2
    exit 1
  fi

  if [ -z "$short_option_alternate" -a -z "$long_option_alternate" ]; then
    echo "$kf:$lineno: cannot document an alternative for option \`$internal'; one does not exist" >&2
    exit 1
  fi

  # do doc-alt
}

function constant {
  # constant K T Hasher header ["comment"]
  check_module_seen

  includes="${includes}
#include \"$4\""
  mkConst_instantiations="${mkConst_instantiations}
#line $lineno \"$kf\"
template <> Expr ExprManager::mkConst($2 const& val);
"
  mkConst_implementations="${mkConst_implementations}
#line $lineno \"$kf\"
template <> Expr ExprManager::mkConst($2 const& val) {
#line $lineno \"$kf\"
  return Expr(this, new Node(d_nodeManager->mkConst< $2 >(val)));
}
"
  getConst_instantiations="${getConst_instantiations}
#line $lineno \"$kf\"
template <> $2 const & Expr::getConst< $2 >() const;
"
  getConst_implementations="${getConst_implementations}
#line $lineno \"$kf\"
template <> $2 const & Expr::getConst() const {
#line $lineno \"$kf\"
  CheckArgument(getKind() == ::CVC4::kind::$1, *this, \"Improper kind for getConst<$2>()\");
#line $lineno \"$kf\"
  return d_node->getConst< $2 >();
}
"
}

function check_doc {
  if $expect_doc; then
    echo "$kf:$lineno: warning: $internal is lacking documentation" >&2
    expect_doc=false
  fi

  if $expect_doc_alternate; then
    echo "$kf:$lineno: warning: $internal is lacking documentation for the alternative option(s): $short_option_alternate $long_option_alternate" >&2
    expect_doc_alternate=false
  fi
}

function check_module_seen {
  if $seen_endmodule; then
    echo "$kf:$lineno: error: command after \"endmodule\" declaration (endmodule has to be last)" >&2
    exit 1
  fi
  if ! $seen_module; then
    echo "$kf:$lineno: error: no \"module\" declaration found (it has to be first)" >&2
    exit 1
  fi
}

while [ $# -gt 0 ]; do
  kf=$1
  seen_module=false
  seen_endmodule=false
  b=$(basename $(dirname "$kf"))
  lineno=0
  # IFS= forces read to read an entire line
  while IFS= read -r line; do
    let ++lineno
    # read any continuations of the line
    while expr "$line" : '.*\\$' &>/dev/null; do
      IFS= read -r line2
      line="$(echo "$line" | sed 's,\\$,,')$line2"
      let ++lineno
    done
    if expr "$line" : '[ 	].*' &>/dev/null; then
      doc "$(echo "$line" | sed 's,^[ 	],,')"
    elif expr "$line" : '\.[ 	]*$' &>/dev/null; then
      doc ""
    elif expr "$line" : '\.' &>/dev/null; then
      echo "$kf:$lineno: error: malformed line during processing of option \`$internal': continuation lines should not have content" >&2
      exit 1
    elif expr "$line" : '/.*' &>/dev/null; then
      doc-alternate "$(echo "$line" | sed 's,^/,,')"
    else
      eval "$line"
    fi
  done < "$kf"
  if ! $seen_module; then
    echo "$kf: error: no module content found in file!" >&2
    exit 1
  fi
  if ! $seen_endmodule; then
    echo "$kf:$lineno: error: no \"endmodule\" declaration found (it is required at the end)" >&2
    exit 1
  fi
  shift
done

## output

# generate warnings about incorrect #line annotations in templates
nl -ba -s' ' "$template"  | grep '^ *[0-9][0-9]* # *line' |
  awk '{OFS="";if($1+1!=$3) print "'"$template"':",$1,": warning: incorrect annotation \"#line ",$3,"\" (it should be \"#line ",($1+1),"\")"}' >&2

text=$(cat "$template")
for var in \
    module_id \
    module_name \
    module_includes \
    module_defaults \
    module_optionholder_spec \
    module_decls \
    module_specializations \
    module_accessors \
    module_short_options \
    module_long_options \
    module_option_handlers \
    include_all_option_headers \
    all_modules_contributions \
    option_handler_includes \
    ; do
  eval text="\${text//\\\$\\{$var\\}/\${$var}}"
done
error="$(echo "$text" | grep '.*\${[^}]*}.*' | head -n 1)"
if [ -n "$error" ]; then
  error="$(echo "$error" | sed 's,.*\${\([^}]*\)}.*,\1,')"
  echo "$template:0: error: undefined replacement \${$error}" >&2
  exit 1
fi
echo "$text" >>"$output"
