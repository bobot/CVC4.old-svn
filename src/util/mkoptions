#!/bin/bash
#
# mkoptions
# Morgan Deters <mdeters@cs.nyu.edu> for CVC4
# Copyright (c) 2011  The CVC4 Project
#
# The purpose of this script is to create options.{h,cpp}
# from template files and a list of options.
#
# Invocation:
#
#   mkoptions template-file options-files...
#
# Output is to standard out.
#

copyright=2011

filename=`basename "$1" | sed 's,_template,,'`

cat <<EOF
/*********************                                                        */
/** $filename
 **
 ** Copyright $copyright  The AcSys Group, New York University, and as below.
 **
 ** This file automatically generated by:
 **
 **     $0 $@
 **
 ** for the CVC4 project.
 **/

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* $1 */

EOF

me=$(basename "$0")

template=$1; shift

includes=

seen_module=false
seen_endmodule=false
expect_doc=false
internal=

function module {
  # module name

  seen_module=true
  if [ -z "$1" ]; then
    echo "$kf:$lineno: error: \"module\" directive missing name" >&2
    exit 1
  elif [ $# -gt 1 ]; then
    echo "$kf:$lineno: error: \"module\" directive has too many arguments" >&2
    exit 1
  fi
}

function endmodule {
  # endmodule
  check_module_seen
  check_doc
  seen_endmodule=true
}

function common-option {
  # common-option option-args...
  handle_option COMMON "$@"
}

function option {
  # option option-args...
  handle_option STANDARD "$@"
}

function expert-option {
  # expert-option option-args...
  handle_option EXPERT "$@"
}

function undocumented-option {
  # undocumented-option option-args...
  handle_option UNDOCUMENTED "$@"
}

function handle_option {
  check_module_seen
  check_doc

  args=("$@")

  category="${args[0]}"
  internal="${args[1]}"
  smtname=
  short_option=
  short_option_alternate=
  long_option=
  long_option_alternate=
  type=

  if [ "$category" = UNDOCUMENTED ]; then
    expect_doc=false
  else
    expect_doc=true
  fi

  # scan ahead to see where the type is
  type_pos=2
  while [ $(($type_pos+1)) -lt ${#args[@]} ] && ! expr "${args[$(($type_pos+1))]}" : ":" &>/dev/null; do
    let ++type_pos
  done

  type="${args[$type_pos]}"

  if [ $type_pos -eq 2 ]; then
    expect_doc=false
  else
    i=2
    while [ $i -lt $type_pos ]; do
      if expr "${args[$i]}" : '--' &>/dev/null || expr "${args[$i]}" : '/--' &>/dev/null; then
        if [ -n "$long_option" -o -n "$long_option_alternate" ]; then
          echo "$kf:$lineno: error: malformed option line for \`$internal': unexpected \`${args[$i]}'" >&2
          exit 1
        fi
        opts=($(echo "${args[$i]}" | sed 's,/, ,'))
        long_option="${opts[0]}"
        long_option_alternate="${opts[1]}"
      elif expr "${args[$i]}" : '-' &>/dev/null || expr "${args[$i]}" : '/-' &>/dev/null; then
        if [ -n "$short_option" -o -n "$short_option_alternate" -o -n "$long_option" -o -n "$long_option_alternate" ]; then
          echo "$kf:$lineno: error: malformed option line for \`$internal': unexpected \`${args[$i]}'" >&2
          exit 1
        fi
        opts=($(echo "${args[$i]}" | sed 's,/, ,'))
        short_option="${opts[0]}"
        short_option_alternate="${opts[1]}"
      else
        if [ -n "$smtname" -o -n "$short_option" -o -n "$short_option_alternate" -o -n "$long_option" -o -n "$long_option_alternate" ]; then
          echo "$kf:$lineno: error: malformed option line for \`$internal': unexpected \`${args[$i]}'" >&2
          exit 1
        fi
        smtname="${args[$i]}"
      fi
      let ++i
    done
  fi

  if [ "$type" = void -a "$internal" != - ]; then
    echo "$kf:$lineno: error: $internal cannot be void-typed; use \`-' as the name if its to be void" >&2
    exit 1
  elif [ "$type" != void -a "$internal" = - ]; then
    echo "$kf:$lineno: error: cannot use an unnamed option if its type is not void" >&2
    exit 1
  fi

  if [ "$type" = bool -a -z "$long_option_alternate" ]; then
    long_option_alternate="--no-$(echo "$long_option" | sed 's,^--,,')"
  fi
  if [ "$type" != bool -a -n "$short_option_alternate" ]; then
    echo "$kf:$lineno: error: cannot use alternate short option $short_option_alternate for \`$internal' because it's not of bool type" >&2
    exit 1
  elif [ "$type" != bool -a -n "$long_option_alternate" ]; then
    echo "$kf:$lineno: error: cannot use alternate long option $long_option_alternate for \`$internal' because it's not of bool type" >&2
    exit 1
  fi
}

function alias {
  # alias (smtname | -option) = (smtname [arg] | -option [arg])+
  check_module_seen
  check_doc
}

function link {
  # link (smtname | -option) : (smtname | -option)+
  # link (smtname | -option) : functor+ [#include "file1" <file2>...]
  check_module_seen
  check_doc
}

function handler {
  # handler (smtname | -option)+ = functor [#include "file1" <file2>...]
  check_module_seen
  check_doc
}

function doc {
  # doc text...
  check_module_seen
  expect_doc=false
}

function doc-alternate {
  # doc-alternate text...
  check_module_seen
  expect_doc=false
}

function constant {
  # constant K T Hasher header ["comment"]
  check_module_seen

  includes="${includes}
#include \"$4\""
  mkConst_instantiations="${mkConst_instantiations}
#line $lineno \"$kf\"
template <> Expr ExprManager::mkConst($2 const& val);
"
  mkConst_implementations="${mkConst_implementations}
#line $lineno \"$kf\"
template <> Expr ExprManager::mkConst($2 const& val) {
#line $lineno \"$kf\"
  return Expr(this, new Node(d_nodeManager->mkConst< $2 >(val)));
}
"
  getConst_instantiations="${getConst_instantiations}
#line $lineno \"$kf\"
template <> $2 const & Expr::getConst< $2 >() const;
"
  getConst_implementations="${getConst_implementations}
#line $lineno \"$kf\"
template <> $2 const & Expr::getConst() const {
#line $lineno \"$kf\"
  CheckArgument(getKind() == ::CVC4::kind::$1, *this, \"Improper kind for getConst<$2>()\");
#line $lineno \"$kf\"
  return d_node->getConst< $2 >();
}
"
}

function check_doc {
  if $expect_doc; then
    echo "$kf:$lineno: warning: $internal is lacking documentation" >&2
    expect_doc=false
  fi
}

function check_module_seen {
  if $seen_endmodule; then
    echo "$kf:$lineno: error: command after \"endmodule\" declaration (endmodule has to be last)" >&2
    exit 1
  fi
  if ! $seen_module; then
    echo "$kf:$lineno: error: no \"module\" declaration found (it has to be first)" >&2
    exit 1
  fi
}

while [ $# -gt 0 ]; do
  kf=$1
  seen_module=false
  seen_endmodule=false
  b=$(basename $(dirname "$kf"))
  lineno=0
  # IFS= forces read to read an entire line, 
  while IFS= read -r line; do
    let ++lineno
    while expr "$line" : '.*\\$' &>/dev/null; do
      IFS= read -r line2
      line="$(echo "$line" | sed 's,\\$,,')$line2"
      let ++lineno
    done
    if expr "$line" : '[ \t].*' &>/dev/null; then
      doc "$(echo "$line" | sed 's,^ ,,')"
    elif expr "$line" : '\.[ \t]*' &>/dev/null; then
      doc ""
    elif expr "$line" : '/.*' &>/dev/null; then
      doc-alternate ""
    else
      eval "$line"
    fi
  done < "$kf"
  if ! $seen_module; then
    echo "$kf: error: no module content found in file!" >&2
    exit 1
  fi
  if ! $seen_endmodule; then
    echo "$kf:$lineno: error: no \"endmodule\" declaration found (it is required at the end)" >&2
    exit 1
  fi
  shift
done

## output

# generate warnings about incorrect #line annotations in templates
nl -ba -s' ' "$template"  | grep '^ *[0-9][0-9]* # *line' |
  awk '{OFS="";if($1+1!=$3) print "'"$template"':",$1,": warning: incorrect annotation \"#line ",$3,"\" (it should be \"#line ",($1+1),"\")"}' >&2

text=$(cat "$template")
for var in \
    includes \
    template \
    getConst_instantiations \
    getConst_implementations \
    mkConst_instantiations \
    mkConst_implementations \
    typechecker_includes \
    typerules \
    ; do
  eval text="\${text//\\\$\\{$var\\}/\${$var}}"
done
error=`expr "$text" : '.*\${\([^}]*\)}.*'`
if [ -n "$error" ]; then
  echo "$template:0: error: undefined replacement \${$error}" >&2
  exit 1
fi
echo "$text"
