
/** DRAFT 1
 * Normal form for predicates:
 *    TRUE
 *    FALSE
 *    var_i |><| b
 *    \sum_i product_i  |><| b
 *  where
 *   1) b is of type CONST_RATIONAL
 *   2) |><| is of type <=, >, =, < or >=
 *   3) product_i is in product normal form,
 *   4) product_i is not 0,
 *   5) product_i's are in strictly ascending productOrder,
 *   6) product_i has at least 2 members,
 *   7) product_1 has a positive coefficient, and
 *   8) var_i has metakind variable.
 *
 * Normal form for terms:
 *    c
 *    c + \sum_i product_i
 *  where
 *   1) c is of type CONST_RATIONAL,
 *   2) product_i is in product normal form,
 *   3) product_i is not a constant,
 *   4) and product_i's are in strictly ascending productOrder.
 *
 * Normal form for products:
 *    d
 *    var_i
 *    e * \prod var_i
 *  where
 *   1) d,e is of type CONST_RATIONAL,
 *   2) e != 0,
 *   3) e != 1 or there are at least 2 variables,
 *   2) var_i is of metakind VARIABLE,
 *   3) and var_i are in increasing (not strict) nodeOrder.
 *
 * productOrder is well defined over normal form products as follows:
 *   cmp(d,d') = rational order.
 *   cmp(d,var_i)= -1
 *   cmp(var_i,var_j) is the node order
 *   cmp(var_i,d * \prod var_i) = -1
 *   cmp(p = d * \prod var_i, p' = d' * \prod var_i')=
 *      if(len(p) == len(p'))
 *      then tupleCompare(var_i, var_i')
 *      else len(p) - len(p')
 */



/** DRAFT 2
 * Normal form for predicates:
 *    TRUE
 *    FALSE
 *    var |><| b
 *    (\sum_{i=1 to N} p_i)  |><| b
 *  where
 *   1) b is of type CONST_RATIONAL
 *   2) |><| is of kind <, <=, =, >= or >
 *   3) p_i is in PNF,
 *   5) p_i's are in strictly ascending <p,
 *   6) N >= 2,
 *   7) the kind of (\sum_{i=1 to N} p_i) is an N arity PLUS,
 *   8) p_1 has coefficient 1, and
 *   9) var has metakind variable.
 *
 * PNF:
 *    v
 *    d * v
 *    (\prod_{i=1 to M} v_i)
 *    d * (\prod_{i=1 to M} v_i)
 *  where
 *   1) d is of type CONST_RATIONAL,
 *   2) d != 0,
 *   3) d != 1,
 *   4) M>=2,
 *   5) v, v_i are of metakind VARIABLE,
 *   6) v_i are in increasing (not strict) nodeOrder, and
 *   7) the kind of (\prod_{i=1 to M} v_i) is an M arity MULT.
 *
 * <p is defined over PNF as follows (skipping some symmetry):
 *   cmp(  v,   v') is the node order over v and v'
 *   cmp(  v,d'*v') is the node order over v and v'
 *   cmp(d*v,d'*v') is the node order over v and v'
 *   cmp(  v,   (\prod v'_i)) = -1
 *   cmp(d*v,   (\prod  v_i)) = -1
 *   cmp(  v, d*(\prod v'_i)) = -1
 *   cmp(d*v, d*(\prod  v_i)) = -1
 *   cmp((\prod_{i=1 to M} v_i),(\prod_{i=1 to M'} v'_i))=
 *      if(M == M')
 *      then tupleCompare(v_i, v'_i)
 *      else M - M'
 *   cmp((\prod_{i=1 to M} v_i), d*(\prod_{i=1 to M'} v'_i))=
 *      if(M == M')
 *      then tupleCompare(v_i, v'_i)
 *      else M - M'
 *   cmp(d * (\prod_{i=1 to M} v_i), d' * (\prod_{i=1 to M'} v'_i))=
 *      if(M == M')
 *      then tupleCompare(v_i, v'_i)
 *      else M - M'
 *
 * Rewrite Normal Form for Terms:
 *    b
 *    p
 *    c + p
 *    (\sum_{i=1 to N} p_i)
 *    c + (\sum_{i=1 to N} p_i)
 *  where
 *   1) b,c is of type CONST_RATIONAL,
 *   2) c != 0,
 *   3) p, p_i is in PNF,
 *   4) N >= 2
 *   5) the kind of (\sum_{i=1 to N} p_i) is an N arity PLUS,
 *   6) and p_i's are in strictly <p.
 *
 */


bool isVarMultList(TNode v){
  for(v = 1 to l.getLength()){
    if(!isVar(v[i])){
      return false;
    }
  }

  for(v = 2 to l.getLength()){
    if(!(v[i-1] <= v[i])){
      return false;
    }
  }
  return true;
}

bool isPNF(TNode p){
   if(p.getKind() == MULT){
     if(p[0].getKind() == CONST_RATIONAL){
       if(p[0].getConst<CONST_RATIONAL>() != 0 &&
          p[0].getConst<CONST_RATIONAL> != 1){
         if(p[1].getKind() != MULT){
           if(p[1].getMetaKind() == VARIABLE){
             return true; // d * v
           }else{
             return false;
           }
         }else{
           if(isVarMultList(p[1])){
             return true; // d * (\prod_{i=1 to M} v_i)
           }else{
             return false;
           }
         }
       }else{
         return false;
       }
     }else{
       if(isVarMultList(p)){
         return true; //(\prod_{i=1 to M} v_i)
       }else{
         return false;
       }
     }
   }else{
     if(p.getMetaKind() == VARIABLE){
       return true; // v
     }else{
       return false;
     }
   }
}


bool <p(TNode p0, TNode p1){
  PNFType t0 = same as the comments in isPNF(p0);
  PNFType t1 = same as the comments in isPNF(p1);

  bool t0IsVar = (t0 == "v") ||(t0 == "d*v");
  bool t1IsVar = (t1 == "v") ||(t1 == "d*v");

  if(t0IsVar && t1IsVar){
    TNode v0 = (t0 == "d*v") ? p0[1] : p0;
    TNode v1 = (t1 == "d*v") ? p1[1] : p1;
    return v0 < v1;
  }else if(!t0IsVar && t1IsVar){
    return false;
  }else if(t0IsVar && !t1IsVar){
    return true;
  }else{
    TNode prod0 = (t0 == "d * (\prod_{i=1 to M} v_i)") ? p0[1] : p0;
    TNode prod1 = (t1 == "d * (\prod_{i=1 to M} v_i)") ? p1[1] : p1;

    int M0 = prod0.getNumChildren();
    int M1 = prod1.getNumChildren();

    if(M0 == M1){
      for(i in 1 to M0){
        if(prod0[i] < prod[i]){
          return true;
        }
      }
      return false;
    }else{
      return M0 < M1;
    }
  }
}

bool isPNFSum(TNode p){

  for(i = 1 to p.getNumChildren()){
    if(!isPNF(p[i])){
      return false;
    }
  }
  for(i = 2 to p.getNumChildren()){
    if(!(p[i-1] <p p[i])){
      return false;
    }
  }
  return true;
}

string isNormalFormTerm(TNode t){
  Kind k = t.getKind();
  if(k != PLUS){
    if(k == CONST_RATIONAL){
      return true; // b
    }else if(isPNF(p)){
      return true; // p
    }else{
      return false;
    }
  }else{
    if(t[0].getKind() == CONST_RATIONAL){
      if(t[0].getConst<CONST_RATIONAL>() != 0){
        if(t[1].getKind() == PLUS){
          if(isPNFSum(t[1])){
            return true; // c + (\sum_{i=1 to N} p_i)
          }else{
            return false;
          }
        }else{
          if(isPNF(t[1])){
            return true; // c + p
          }else{
            return false;
          }
        }
      }else{
        return false;
      }
    }else{
      if(isPNFSum(t)){
        return true; // (\sum_{i=1 to N} p_i)
      }else{
        return false;
      }
    }
  }
}

/***********************************************/
/***********************************************/
/******************* DRAFT 3 *******************/
/***********************************************/
/***********************************************/

/** DRAFT 3
 * Normal form for predicates:
 *    TRUE
 *    FALSE
 *    v |><| b
 *    p |><| b
 *    (+ p_1 .. p_N)  |><| b
 *  where
 *   1) b is of type CONST_RATIONAL
 *   2) |><| is of kind <, <=, =, >= or >
 *   3) p, p_i is in PNF,
 *   5) p_i's are in strictly ascending <p,
 *   6) N >= 2,
 *   7) the kind of (+ p_1 .. p_N) is an N arity PLUS,
 *   8) p.d, p_1.d are 1, and
 *   9) v has metakind variable.
 *
 * PNF(t):
 *    (* d v_1 v_2 ... v_M)
 *  where
 *   1) d is of type CONST_RATIONAL,
 *   2) d != 0,
 *   4) M>=1,
 *   5) v_i are of metakind VARIABLE,
 *   6) v_i are in increasing (not strict) nodeOrder, and
 *   7) the kind of t is an M+1 arity MULT.
 *
 * <p is defined over PNF as follows (skipping some symmetry):
 *   cmp( (* d v_1 v_2 ... v_M), (* d' v'_1 v'_2 ... v'_M'):
 *      if(M == M'):
 *      then tupleCompare(v_i, v'_i)
 *      else M -M'
 *
 * Rewrite Normal Form for Terms:
 *    b
 *    v
 *    (+ c p_1 p_2 ... p_N)  |  not(N=1 and c=0 and p_1.d=1)
 *  where
 *   1) b,c is of type CONST_RATIONAL,
 *   2) c != 0,
 *   3) p_i is in PNF,
 *   4) N >= 1
 *   5) the kind of (+ c p_1 p_2 ... p_N) is an N+1 arity PLUS,
 *   6) and p_i's are in strictly <p.
 *
 */


/* Assuming that the terms have been normalized, how much work is the case splitting.
 * The following should provide a good insight into how difficult it is to use
 * these normal forms when writing code.
 */

enum PredicateNFKind{TRUE, FALSE, v |><| b, p |><| b, (+ p_1 .. p_N)  |><| b};

PredicateNFKind kindOfNormalFormPredicate(TNode n){
  if(n.getKind() == CONST_BOOLEAN){
    if(n.getConst<bool>()){
      return TRUE;
    }else{
      return FALSE;
    }
  }else{
    TNode left = n[0];
    if(left.getMetaKind() == metakind::VARIABLE){
      return v |><| b;
    }else if(left.getKind() == MULT){
      return p |><| b;
    }else{
      return (+ p_1 .. p_N)  |><| b;
    }
  }
}

enum TermNFKind{c, v, (+ c p_1 p_2 ... p_N)};

TermNFKind kindOfTermNFKind(TNode n){
  if(n.getMetaKind() == metakind::CONSTANT){
     return c;
  }else if(n.getMetaKind() == metakind::VARIABLE){
     return v;
  }else{
     return (+ c p_1 p_2 ... p_N) 
  }
}


/* Verify that the term meets all of the criteria for a normal form.
 * This should provide good insight into how difficult it is to write/debug
 * the rewriters themselves, and other parts of the code that are
 * "highly knowledgable" about the normal form (such as helper functions).
 */


bool rangeIsSorted(bool strict, TNode::iterator start, TNode::iterator stop, NodeComparitor cmp){
  if(start == stop) return true;
  TNode prev = *start;
  ++start;
  while(start != stop){
    TNode curr = *start;
    int tmp = cmp(prev, curr);
    if(strict && tmp >= 0
      !strict && tmp > 0
    ){
      return false;
    }
    prev = curr;
    ++start;
  }
  return true;
}

bool rangeAll(TNode::iterator start, TNode::iterator stop, NodePredicate rho){
  for(;start != stop; ++start){
    if(! rho(*start))  return false;
  }
  return true;
}
bool isPNF(TNode p){
   return
      p.getKind() == MULT &&
      p[0].getKind() == CONST_RATIONAL&&
      p[0].getConst<CONST_RATIONAL>() != 0 &&
      rangeIsSorted(false, p.begin()+1, p.end(), nodeOrder) &&
      rangeAll(p.begin()+1, p.end(), \t -> t.getMetaKind() == metakind::VARIABLE);
}


bool cmpPNF(TNode p0, TNode p1){
  int M0 = p0.getNumChildren();
  int M1 = p1.getNumChildren();

  if(M0 == M1){
    for(int i=1; i< M0; ++i){
      int cmp = nodeOrder(p0[i],p1[i]);
      if(cmp != 0){
        return cmp;
      }
    }
    return 0;
  }else{
    return M0 - M1;
  }
}

bool isNormalFormTerm(TNode t){
  if(t.getKind() == CONST_RATIONAL){
    return true;
  }else if(t.getMetaKind() == VARIABLE){
    return true;
  }else if(t.getKind() == PLUS){ //may be (+ c p_1 p_2 ... p_N)
    int N = t.getNumChildren()-1;
    TNode c = t[0];
    return c.getKind() == CONST_RATIONAL &&
           c.getConst<Rational>() !- 0 &&
           N >= 1 &&  //This check is redundent because of an invariant in NodeBuilder<>
           rangeAll(p.begin()+1, p.end(), isPNF) &&
           rangeIsSorted(true, p.begin()+1, p.end(), cmpPNF);
  }else{
    return false;
  }
}

bool isNormalFormAtom(TNode n){
  if(n.getKind() == CONST_BOOLEAN){
    return true;
  }else if(n.getKind() \in {<, <=, ==, >=, >}){
    TNode left = n[0];
    TNode right = n[1];
    if(right.getKind() == CONST_RATIONAL){
      if(left.getMetaKind() == VARIABLE){
        return true;
      }else if(left.getKind() == MULT){
        return isPNF(left) && left[0] == 1;
      }else if(left.getKind() == PLUS){
        return left.getNumChildren() >= 2 &&
               rangeAll(left.begin(), left.end(), isPNF) &&
               left[0][0] == 1 &&
               rangeIsSorted(true, left.begin(), left.end(), cmpPNF);
      }else{
        return false;
      }
    }else{
      return false;
    }
  }else{
    return false;
  }
}

/***********************************************/
/***********************************************/
/******************* DRAFT 4 *******************/
/***********************************************/
/***********************************************/

/** DRAFT 4
 * variable := n
 *   guards
 *     n getMetaKind() == metakind::VARIABLE

 * constant := n
 *   guards
      n.getKind() == kind::CONST_RATIONAL

 * monomial := variable | (* [variable])
 *   guards
 *     len [variable] >= 2
 *     isSorted nodeOrder (getMList monomial)


 * coeff_mono := monomial | (* coeff monomial)
 *   guards
 *     coeff is renaming for constant
       coeff \not\in {0,1}

 * sum := coeff_mono | (+ [coeff_mono])
 *   guards
 *     len [coeff_mono] >= 2
 *     isStronglySorted cmono_cmp [coeff_mono]

 * cons_sum := sum |  (+ constant_1 sum) | constant_0
 *   guards
 *     constant_1, constant_0 are accepted by constant
 *     constant_1 != 1

 * comparison := leads_with_one |><| constant
 *   guards
 *     |><| is GEQ, EQ, LEQ
 *     isStronglySorted cmono_cmp (monomial::[coeff_monomial])
 *     leads with_one is a subexpression of sum s.t. it is also accepted by
 *     leads_with_one :=  monomial | (+ monomial [coeff_monomial])

 * Normal Form for terms := cons_sum
 * Normal Form for atoms := TRUE | FALSE | comparison | (not comparison)
 *
 * Important Notes:
 *
 *  The languages for each are stratified. i.e. it is either the case that
 *  they or all of their children belong to a language that is strictly
 *  smaller according to the following partial order.
 *    constant -> monomial -> coeff_mono -> sum -> cons_sum
 *    variable                                     comparison
 *  This partial order is not unique, but it is simple.
 *
 *  This gives rise to the notion of the tightest language that accepts a node,
 *  which is simply the least according to the stratification order above.
 *
 *  Each subexpression of a normal form is also a normal form.
 *
 *  The tightest language that accepts a node does not always indicate the
 *  tighest language of the children:
 *     (+ v1 (* v1 v2) (* 2 (* v1 v2 v2)))

 * TAGGING:
 *  A node in normal form is tagged with the tightest binding above that
 *  accepts/generates it.
 *  All subexpressions are also in normal form and are also tagged.
 *  The tags for terms are as follows:
 *    enum { CONSTANT, VARIABLE, MONOMIAL, COEFF_MONOMIAL, SUM, CONS_SUM};
 */

 Auxillary
 let rec tuple_cmp elem_cmp pairs_list =
      match pair_list with
         [] -> 0
        |(x,y)::ps -> let cmp_res = elem_cmp x y in
                       if cmp_res <> 0
                       then cmp_res
                       else tuple_cmp elem_cmp ps

 let lex_cmp elem_cmp l0 l1 =
      if len l0 == len l1
      then tuple_cmp elem_cmp (zip l0 l1)
      else (len l0) - (len l1)

 let rec adjacent l =
      mathc l with
       a::b::xs -> (a,b)::(adjacent b::xs)
      | _ -> []

 let isWeaklySorted cmp l =
     forall (fun (x,y) -> cmp x y <= 0) (adjacent l)

 let isStronglySorted cmp l =
     forall (fun (x,y) -> cmp x y < 0) (adjacent l)

 let getMList monomial =
         match monomial with
           variable -> [variable]
          |(* [variable]) -> [variable]

 let drop_coeff coeff_mono =
      match coeff_mono in
         monomial -> monomial
        |(* coeff monomial) -> monomial

let mono_cmp m0 m1 = lex_cmp nodeOrder (getMList m0) (getMList m1)
let cmono_cmp cm0 cm1 = mono_cmp (drop_coeff cm0) (drop_coeff cm1)

