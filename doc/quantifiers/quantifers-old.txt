
\begin{comment}
Now, let us focus on identifying states in which there does not exist any useful instantiations with regards to assumptions about our counterexample.
The basic idea is to find a literal $\l \mapsto^I \psi$ in $M$ such that $\forall \bar{x}. \neg l[\bar{x}/\bar{e}]$ is satisifiable in $M$.
We call such a literal to be $\emph{compatible}$ in $M$.
For example, a EUF literal $f( t_1, \ldots, t_n ) = s$ is compatible if for all terms of the form $f( s_1, \ldots, s_n )$, we have that $t_1 \neq s_1, \ldots t_n \neq s_n$.
That is, the domain of $f( t_1, \ldots, t_n )$ is disjoint from all other terms with top symbol $f$.

Given a theory $T$, we will define search method that will drive the DPLL(T) search with splitting lemmas of the form $( l \vee \neg l )$.
The idea is to chose such lemmas such that the DPLL(T) search will either reach a state $M \parallel F$ such that $\psi$ is instantiation-ready in $M$, or there exists some literal $l \mapsto^I \psi$ that is compatible in $M$.
\end{comment}

We will describe search strategies for instantiations in terms of transition relations $\rightarrow$ between sets of assertions.
We call a set of assertions $M$ \emph{terminal for quantifier instantiation with repect to $P$} if one of the following hold:

(1) $M$ is $T$-inconsistent,

(2) there exists a $\psi$ that is instantiation-ready in $M$, or

(3) $P(M)$ holds.

A relation $\rightarrow$ is \emph{terminiating for quantifier instantiation with respect to $P$} if there does not exist an infinite chain $M \rightarrow M_1 \rightarrow \ldots,$ such that $M, M_1, \ldots$ are non-terminal for quantifier instantiation with respect to $P$.
Here, $P$ represents a termination condition for our search, or in other words, $P(M)$ holds when we decide that it is no longer useful for search for instantiations.

Define $Inst( \rightarrow, P, M )$ as the set of instantiations collected by searching $M$ by relation $\rightarrow$ with termination condition $P$.
In other words, $Inst( \rightarrow, P, M )$ contains all $[\varepsilon_{M'}(\bar{e})/\bar{e}]$ such that $\rightarrow$ reaches a state $M'$ in which some $\psi$ is instantiation-ready in $M'$ where $\bar{e} \mapsto^I \psi$.

A relation $\rightarrow$ \emph{logically complete} if $\bigvee \{ M' \backslash M \mid M \rightarrow M' \}$ is a tautology for all $M$.
Note that by Theorem~\ref{thm:instready}, a candidate-satisfiable state $M \parallel F$ is in conflict if there exists a relation $\rightarrow$ that is logically complete and terminating for quantifier instantiation with respect to $P$, and there does not exist a $M'$ such that $M \rightarrow^\ast M'$ and $P(M)$ holds.

Our search strategies collect sets of relevant instantiations $Inst( \rightarrow, P, M )$ that are used for generating instantiation clauses.
We use the following rule for $\forall$-Inst, now with the specification of how our instantiations are constructed: \\

\noindent $\forall$-Inst (Collected Instantiation for $\rightarrow,P$): \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi[ \bar{ x } ] \vee \varphi( \bar{ s } )$, if   
$\begin{cases}
  M \parallel F \text{ is candidate-satisfiable}, \\
  [\bar{ s }/\bar{e}] \in Inst( \rightarrow, P, M ), \\ 
  \bar{e} \mapsto^I \forall \bar{x}. \varphi[ \bar{ x } ], \\
  P( M ) \text{ does not hold}. \\ 
\end{cases}$ \\

We call this approach the \emph{collected instantiation search} approach for quantifier instantiation.
In this approach, it is recommended that all instantiations computed by $Inst( \rightarrow, P, M )$ are applied at the same time.
Depending on the strategy used, a large or small number of instantiations may be generated.
In the case in which no instantiations are generated, the SMT solver must either answer unknown, or backtrack and reverse some decision $l^d$ to $\neg l^d$.

It may also be helpful to add learned lemmas in cases in which our instantiation search reaches $T$-inconsistent states $M'$, as such lemmas will help prune the search space of subsequent searches.

As a naive approach, one could use an incomplete search strategy $\rightarrow$ for guessing instantiations for $\psi$, such that $M \rightarrow M'$ if and only if $M' = M, (e = t)$ for some concrete ground term $t$ and instantiation constant $e \mapsto^I \psi$ that is not equal to any concrete ground term.
In this approach, $t$ represents a guess for $e$.

%Define the termination predicate $P_{\mid Inst \mid = n}$ as 
%We will define a terminating search strategy $\rightarrow_\psi$ by the use of splitting literals $l^\psi_M$.
%Define the relation $\rightarrow_{\psi+}$ between sets of assertions such that $M \rightarrow_{\psi+} M'$ if and only if $M' = M, l^\psi_M$, and similarly $M \rightarrow_{\psi-} M'$ if and only if $M' = M, \neg l^\psi_M$.
%Define the relation $M \rightarrow_\psi M'$ as $\rightarrow_{\psi+} \cup \rightarrow_{\psi-}$. 

One might also wish to perform the instantiations encountered in this strategy immediately.
Instead of the previous rule which computes the instantiations $Inst( \rightarrow, P, M )$ and applies them all at once, we may instead use the following rules for implementing an instantiation search according to $\rightarrow$ and $P$: \\

\noindent $\forall$-Inst (Incremental Instantiation for $\rightarrow,P$): \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi[ \bar{ x } ] \vee \varphi( \varepsilon_M( \bar{ e } ) )$, if   
$\begin{cases}
  M \parallel F \text{ is candidate-satisfiable}, \\
  \forall \bar{x}. \varphi[ \bar{ x } ] \text{ is instantiation-ready in $M$}, \\
  \bar{e} \mapsto^I \forall \bar{x}. \varphi[ \bar{ x } ]. \\
\end{cases}$ \\

$M \parallel F \Longrightarrow M \parallel F, C$, if   
$\begin{cases}
  M \parallel F \text{ is candidate-satisfiable}, \\
  C = \bigvee \{ l \mid \exists M' = M, l. \ M \rightarrow M' \}, \\ 
  P( M ) \text{ does not hold}. \\
\end{cases}$ \\

We call this the \emph{incremental instantiation search} approach for quantifier instantiation.
An obvious advantage to this approach is that instantiations are performed immediately, which subsequently can be used to determine new instantiations.
In addition, we avoid repeating a lot of work if the instantiations are found deep in a search.

However, there are two possible downsides to this approach.
First, adding splitting lemmas may pollute the search space of the SMT solver, and may be burdensome to the system.
A possibly stronger downside is that a matching loop may occur, where instantiation clauses in the first rule creates terms that lead to splitting lemmas in the second rule, and splitting in the second rule leads to an instantiation in the first rule, and so on.
A stronger notion of fairness needs to be considered in this approach as compared to collected instantiation search.

\paragraph{Generic Search Strategies}

Here, we define several search strategies and termination conditions that are generic.

Say we wish to assign a fresh constant to the value of unsolved instantiation constants.
Define the relation $\rightarrow_{e=c}$ as the following: 
Find the maximal $n$ for which $M \models e_1 = \ldots = e_n$ and $e_1$ is unsolved in $M$.  
Then, $M \rightarrow_{e=c} M'$ if and only if $M' = M, (e_1 = c)$ for fresh constant $c$.

Define a corresponding termination condition.
We say $P^n_{e=c}$ holds for $M$ if there does not exist instantiation constants $e_1, \ldots, e_n$ that are unsolved in $M$ and are such that $M \models e_1 = \ldots = e_n$.  
For example, $P^2_{e=c}$ corresponds to the condition that no unsolved instantiation constants are equivalent in $M$.

A composition of relations $(\rightarrow, \rightarrow')$ describes a search strategy in which the second relation is applied only when the first one is not applicable.
Formally, $M (\rightarrow, \rightarrow') M'$ if and only if (a) $M \rightarrow M'$ or (b) $M \not\rightarrow M''$ for all $M''$ and $M \rightarrow' M'$.

It may be helpful to restrict a relation to a termination condition.
We say that $M \rightarrow \mid_P M'$ if and only if $M \rightarrow M'$ and $P( M )$ does not hold.

\subsection{Search Strategy for Quantifier Instantiation in EUF}

We begin with a motivating example: \\

{\bf Example 3}
Consider the set of clauses $S = \{ (\psi :)\forall x. (f( x ) = x) \wedge f( f( a ) ) \neq a \}$.  Note that this formula is unsatisifiable.
After applying unit propagation twice, Counterexample $\forall$-Inst, deciding $\neg (\bot^{\neg \psi})^d$, after unit propagation we arrive at the DPLL(T) state $f( f( a ) ) \neq a, \psi, \neg (\bot^{\neg \psi})^d, f(e) \neq e \parallel (S':)S \cup \{ ( \neg \psi \vee \bot^{\neg \psi } \vee f( e ) \neq e ) \}$.
Note that $M \parallel F$ is candidate-satisfiable and $\psi$ is not instantiation-ready. \\

The idea behind our instantiation search in EUF is to resolve ambiguity between concrete ground terms and terms with instantiation constants with the same top symbol.
In Example 3, we do not know whether $f( f( a ) )$ and $f( e )$ represent the same term, since conceptually the value of the (potential) counterexample $e$ to $\psi$ is undetermined.
We will see that this will cause our search procedure add the splitting lemma $( e = f( a ) \vee e \neq f( a ) )$, for which $\psi$ is instantiation-ready in the former case.

First, we begin with the following terminology for non-instantiation constant terms $t \mapsto^I^ \psi$.
A term $f( t_1, \ldots, t_n ) \mapsto^I \psi$ is \emph{equality-compatible with term $s$ in $M$} if and only if $s$ is of the form $f( s_1, \ldots s_n )$ and $M \models_T t_1 = s_1 \wedge \ldots \wedge t_n = s_n$.
Similarly, a term $f( t_1, \ldots, t_n ) \mapsto^I \psi$ is \emph{equality-independent from term $s$ in $M$} if (a) $s$ is of the form $g( s_1, \ldots s_m )$, or (b) $s$ is of the form $f( s_1, \ldots s_n )$ in $M$, and $M \models_T t_i \neq s_i$ for some $i$. 

A term $t$ is simply \emph{equality-independent in $M$} if $t$ is equality-independent from all other terms $s \in M$.  
A pair of terms $t, s$ is \emph{equality-ambiguous} if $t$ is neither equality-compatible nor equality-independent from $s$.

For an equality-ambiguous pair of terms $t, s$ of the form $f( t_1, \ldots, t_n ), f( s_1, \ldots s_n )$, we define $NArgs( t, s )$ as the number of arguments of $t$ and $s$ such that $M \models (t_i = s_i)$, and $NArgs'( t, s )$ as the number of arguments of $t$ and $s$ such that $M \not\models (t_i = s_i)$

We will define a search strategy that leads to states $M'$ in which some quantified formula $\psi \in M'$ is instantiation-ready, or that no sufficient pair of equality-ambiguous terms $t, s$ can be found.
We first informally describe the strategy in general terms and discuss the heuristics we use for guiding our search.

As eluded to, the idea behind our search is to find equality-ambiguous pairs of terms $t, s$ where $t \mapsto^I \psi$ and add splitting lemmas that either will drive $t$ to be equality-compatible or equality-independent from $s$.
We prefer pairs $t, s$ such that $s$ is a concrete ground term with maximum likelihood that $t$ is equal to $s$ in a real counterexample.
Thus, we first prefer $s$ such that $M \models_T t = s$, then those in which $M \not\models_T t \neq s$.
In the latter case, we may prefer $s$ such that $M \models_T t \neq c_1 \neq \ldots \neq c_n \neq s$, with a minimal length $n \geq 2$.
As additional heuristics, we chose $s$ such that $NArgs'( t, s )$ is minimized, and pairs that where $t, s$ are of minimum size.

Once we have chosen an equality-ambiguous pair of terms $t,s$ that is maximal with respect to this heuristic, if $t, s$ are of the form $f( t_1, \ldots t_n ), f( s_1 \ldots s_n)$, we chose subterms $t_i', s_i'$ of arguments $t_i, s_i$ such that $M \not\models ( t_i' = s_i' )$ and $t_i'$ and $s_i'$ share a common prefix in $t_i$ and $s_i$ that is maximized.
We then chose to split our search by exploring both $t_i' = s_i'$ and $t_i' \neq s_i'$.
For example, if we have the equality-ambiguous pair $f( g( e ), e ), f( g( a ), g( b ) )$, we will chose to explore $e = a$ and $e \neq a$ in the case that $M \not\models e = a$.
We call the terms $t_i', s_i'$ the \emph{maximal depth ambiguity for $t, s$}.
%The maximal depth ambiguity for the equality-ambiguous pair $e, s$ is simply $e = s$.

Define a total ordering $\succeq$ between equality-ambiguous pairs of terms:

\begin{definition}
Define an ordering $\succeq$ between equality-ambiguous pairs of terms, such that $t,s \succeq t',s'$ in $M$ if $t,s$ satisfy a higher lexical combination than $t',s'$ of the following properties in descending order of importance:  \\
(P1) $M \not\models_T (t \neq s)$, \\
(P2) $t$ is unsolved in $M$, \\
(P3) $s$ is solved in $M$, \\
(P4) $M \models_T (t = s)$, \\
(P5) (minimum) value of $NArgs'( t, s )$, \\
(P6) (maximum) value of $NArgs( t, s )$, \\
(P7) (maximum) prefix size for maximal depth ambiguity for $t,s$, \\
(P8) (minimum) number of symbols in the maximal depth ambiguity for $t,s$.
\end{definition}

We are now ready to define the following search procedure $\rightarrow_{eamb}$ that is based on resolving equality-ambiguous pairs of terms in a state $M$ according to this ordering:

\begin{definition}
If there exists a pair of equality-ambiguous terms in $M$, then say $t, s$ is the maximal pair with respect to $\succeq$.
Then, $M \rightarrow_{eamb} M'$ if and only if $M' = M, (\neg)(t_i' = s_i')$, where $t_i', s_i'$ is the maximal depth ambiguity of $t, s$. 
\end{definition}

In other words, if an equality-ambiguous pair of terms $t,s$ exist in $M$, then attempt to resolve them. 
We will first consider the search strategy $( \rightarrow_{eamb} \mid_{Pemb}, \rightarrow_{e=c} )$ for EUF with termination condition $P^2_{e=c}$, where $P_{emb}$ is a requirement on how helpful it is to resolve equality-ambigity between $t$ and $s$. \\

{\bf Example 3, Continued}
Given the set of clauses $S = \{ (\psi :)\forall x. (f( x ) = x) \wedge f( f( a ) ) \neq a \}$, say we reach the DPLL(T) state $f( f( a ) ) \neq a, \psi, \neg (\bot^{\neg \psi})^d, f(e) \neq e \parallel (S':)S \cup \{ ( \neg \psi \vee \bot^{\neg \psi } \vee f( e ) \neq e ) \}$.
Let us say we decide to perform incremental quantifier instantiation according to $( \rightarrow_{eamb}, \rightarrow_{e=c} )$.

\begin{comment}
THIS IS FOR COLLECTED INSTANTIATION
Our maximum pair of equality-ambiguous terms is $f( e ), f( f( a ) )$ and our maximal depth ambiguity is $e = f( a )$.
Searching the branch $e = f( a )$ leads us to a state in which $\psi$ is instantiation-ready with the instantiation $[f(a)/e]$ and $e \neq f( a )$ leads us to a state in which $f( e )$ is equality-independent and our search terminates.
Our search has thus calculated the set $\{ [f(a)/e] \}$.
By applying this instantiation, we obtain the clause $( \neg \psi \vee f( f( a ) ) = f( a ) )$, and after unit propagation we are in the state $f( f( a ) ) \neq a, \psi, \neg (\bot^{\neg \psi})^d, f(e) \neq e, f( f( a ) ) = f( a ) \parallel S'$.
Again, $\psi$ is not instantiation-ready, and we may chose to perform another round of instantiation.

Our maximum pair of equality-ambiguous terms is $f( e ), f( a )$ and our maximal depth ambiguity is $e = a$.
Searching the branch $e = a$ leads us to a state in which $\psi$ is instantiation-ready with the instantiation $[a/e]$.
Otherwise, searching the branch $e \neq a$ leads us to state where we again will split on $e = f( a )$.
In the branch $e = f( a )$, we get the theory conflict $e = f( a ), f( f( a ) ) = f( a ), f( e ) \neq e \models \bot$.
In the branch $e \neq f( a )$, we have that $f( e )$ is equality-independent and our search terminates.
Our search has thus calculated the set $\{ [a/e] \}$, and after adding the instantiation clause $( \neg \psi \vee f( a ) = a )$, the solver answers UNSAT. \\
\end{comment}

Our maximum pair of equality-ambiguous terms is $f( e ), f( f( a ) )$ and our maximal depth ambiguity is $e = f( a )$.
Searching the branch $e = f( a )$ leads us to a state in which $\psi$ is instantiation-ready with the instantiation $[f(a)/e]$.
By applying $\forall$-Inst to $\psi$, we obtain the clause $( \neg \psi \vee f( f( a ) ) = f( a ) )$, and after unit propagation we have the theory conflict $f( f( a ) ) = f( a ), e = f( a ), f( e ) \neq e \models \bot$.
After conflict analysis, we backjump to the state $f( f( a ) ) \neq a, \psi, \neg (\bot^{\neg \psi})^d, f(e) \neq e, e \neq f( a ), f( f( a ) ) = f( a ) \parallel S''$.
Again, $\psi$ is not instantiation-ready, and we may chose to perform another split.

Our maximum pair of equality-ambiguous terms is $f( e ), f( a )$ and our maximal depth ambiguity is $e = a$.
Searching the branch $e = a$ leads us to a state in which $\psi$ is instantiation-ready with the instantiation $[a/e]$.
After adding the instantiation clause $( \neg \psi \vee f( a ) = a )$, the solver answers UNSAT. \\

In the previous example, we have found the relevant instantiations $[f(a)/x]$ and $[a/x]$, which has led us to contradict the ground clause $f( f( a ) ) \neq a$.
This was accomplished by using splitting lemmas to explore our search space, and identifying cases in which we can generate unsatisfiable instantiation clauses. \\

{\bf Example 4}
Consider the set of clauses $S = \{ (\psi_1 :)\forall x. f(x) \neq a, (\psi_2 :)\forall y. f(y) = a \}$.
After applying unit propagation twice, Counterexample $\forall$-Inst twice, after unit propagation we arrive in the DPLL(T) state $\psi_1, \psi_2,$ $\neg (\bot^{\neg \psi_1})^d$, $\neg (\bot^{\neg \psi_2})^d$, $f(e_1) = a, f(e_2) \neq a \parallel S'$.
Again, let us say we decide to perform quantifier instantiation according to $( \rightarrow_{eamb}, \rightarrow_{e=c} )$.
After determining the maximum pair $f(e_1),f(e_2)$, we split on $( e_1 = e_2 )$.

In the branch where $e_1 = e_2$, we have that $\rightarrow_{e=c}$ applies.
We explore the branch $e_1 = c$ for fresh constant $c$, and immediately we have that $\psi_1$ and $\psi_2$ are both instantiation ready with instantiations $[c/e_1]$ and $[c/e_2]$.
%In the branch where $e_1 \neq e_2$, both $f( e_1 )$ and $f( e_2 )$ are equality-independent and our search terminates.
%Our search has computed the set $\{ [c/e_1], [c/e_2] \}$.
After applying the instantiations $\psi_1[c/x]$ and $\psi_2[c/x]$ we obtain the conflict $f( c ) = a, f( c ) \neq a \models \bot$, and the solver will answer UNSAT. \\

The following example demonstrates how this heuristic can be an improvement over simple E-matching: \\

{\bf Example 5}
Consider the set of clauses $S = \{ (\psi :) \ \forall xy. g( x ) \neq f( y ), g( a_1 ) = f( b_1 ), \ldots, g( a_n ) = f( b_n ) \}$.
In E-matching, we have $n$ possible matches for both $x$ and $y$ and potentially $O(n^2)$ pairs of matches can be tried until a proper instantiation is found. 
\footnote{ In this example, the structure of the input may lead us to find a proper instantiation.
However, one could envision a similar example in which we have a set of clauses in $F$ such that $F \models g( a_1 ) = f( b_1 ), \ldots, g( a_n ) = f( b_n )$, and a quantifier $\forall xy. \varphi(x,y)$ such that $\neg \varphi( x, y ) \models g( x ) = f( y )$ and no structural information about the input is helpful. }
In constrast, it can be shown that the first instantiation tried by the strategy $( \rightarrow_{eamb}, \rightarrow_{e=c} )$ leads to a conflict.

After applying unit propagation and Counterexample $\forall$-Inst to $\psi$, we reach the DPLL(T) state $\psi, \neg (\bot^{\neg \psi})^d, g( e_1 ) = f( e_2 ), g( a_1 ) = f( b_1 ), \ldots, g( a_n ) = f( b_n ) \parallel S'$.
Note that all equality-ambiguous pairs $g( e_i ), g( a_i )$ and $f( e_j ), f( b_j )$ are equivalent with respect to our ordering for all $i,j$.

Say we chose some $g( e_1 ), g( a_i )$, and thus are interested in splitting on $e_1 = a_i$.
In the branch $e_1 = a_i$, we will find that $f( e_2 ) = g( e_1 ) = g( a_i ) = f( b_i )$, and thus $f( e_2 ), f( b_i )$ becomes maximal with respect to our ordering.
Our search will explore $e_2 = b_i$ and subsequently apply the instantiation $[ a_i/e_1, b_i/e_2]$. 
This instantiation leads to a conflict, and the solver answers UNSAT.  \\

The following example demonstrates how this heuristic can be used to instantiate axioms representing the encoding of simple arithmetic functions: \\

{\bf Example 6}
Consider the set of clauses $S = \{ (\psi_1 :) \ \forall x. G( S( x ), x), (\psi_2 :) \forall xyz. (G(x,y) \wedge G(y,z)) \Rightarrow G(x,z), \neg G( S(S(a)), a) \}$.
Note that $S$ represents a successor function and $G$ represents ``is greater than".  
In other words, this set of clauses says that $a + 2 > a$ is not true for some constant $a$.

After unit propagations and Counterexample $\forall$-Inst, we have the set of assertions $\psi_1, \psi_2, \neg ( \bot^{\neg \psi_1 })^d, \neg ( \bot^{\neg \psi_2 })^d$, $G( S(S(a)), a) =$ $G( S(e_1), e_1) =$ $G( e_2, e_4 ) =$ $\bot$, $G( e_2, e_3 ) =$ $G( e_3, e_4 ) =$ $\top$, where $\top$ and $\bot$ are the distinguished free boolean constant representing true and false, $e_1 \mapsto^I \psi_1$ and $e_2, e_3, e_4 \mapsto^I \psi_2$.
Our maximum equality-ambiguous pair is $G( S(S(a)), a), G( S(e_1), e_1)$ with maximum depth ambiguity $e_1 = S( a )$.
In the branch $e_1 = S( a )$, $\psi_1$ is instantiation-ready, and we apply the instantiation $\psi_1[S(a)/e_1]$.

After conflict analysis and backjump, we have the set of assertions $G( S(S(a)), a) =$ $G( S(e_1), e_1) =$ $G( e_2, e_4 ) =$ $\bot$, $G( e_2, e_3 ) =$ $G( e_3, e_4 ) =$ $G( S( S( a ) ), S( a )) =$ $\top$, and $e_1 \neq S( a )$.
Our maximum equality-ambiguous pair is $G( S(S(a)), a), G( e_2, e_4 )$ and we branch on $e_4 = a$.
After branching, this pair is again maximal (because of $NArgs'$) and we branch on $e_2 = S( S( a ) )$.
After this, our maximal pair is $G( e_2, e_3 ), G( S( S( a ) ), S( a ))$ by $NArgs'$ and we branch on $e_3 = S( a )$.
Now, $\psi_2$ is instantiation-ready and we obtain the instantiation clause $( \neg \psi_2 \vee \neg G(S( S( a ) ),S( a )) \vee \neg G(S( a ),a) \vee G(S( S( a ) ),a))$.

After conflict analysis and backjump, we have the set of assertions $G( S(S(a)), a) =$ $G( S(e_1), e_1) =$ $G( e_2, e_4 ) =$ $G(S( a ),a) =$ $\bot$, $G( e_2, e_3 ) =$ $G( e_3, e_4 ) =$ $G( S( S( a ) ), S( a )) =$ $\top$, $e_1 \neq S( a )$, and $e_3 \neq S( a )$.
Our maximal pair is $G( S(e_1), e_1), G( S( a ), a )$ and we split on $e_1 = a$.
In the branch $e_1 = a$, $\psi_1$ is instantiation-ready, and we apply the instantiation $\psi_1[a/e_1]$ and the solver will answer UNSAT. \\

The default behavior of our search strategy has calculated three instantiations, representing $a + 2 > a + 1$, $a + 2 > a + 1 > a$ and $a + 1 > a$.
These instantiations were judged on relevance, taking precise relationships between concrete ground terms into account when chosing which axiom to instantiate.

\paragraph{Other heuristics}

The search strategy $( \rightarrow_{eamb}, \rightarrow_{e=c} )$ is useful for finding relevant instantiations based on the relationships between values in our counterexample.
It is based on finding two terms that are likely to be equal in a real counterexample, and resolving such the ambiguity between them.
In the following, we describe similar heuristics based on looking at relationships between terms on a larger scope.

Say we are in a state $M$ where there does not exist an equality-ambiguous pair of terms $t,s$ such that $M \models t = s$.
Instead of finding a maximal pair of terms $t',s'$ in $M$, we could chose to look for a pair of equivalence classes $E_1, E_2$ such that $E_1$ and $E_2$ contain a maximal number of equality-ambiguous terms.
We may then chose the maximal pair of equality-ambiguous terms $t,s$ where $t \in E_1$ and $s \in E_2$ or vice versa.
We call this strategy $\rightarrow_{Eamb}$.

Yet another heuristic is to find splits $( t_i = s_i \vee t_i \neq s_i )$ that resolve ambiguity in a maximal number of arguments in all pairs of terms.
For example, if our state $M$ contains many pairs of terms of the form $f_1( a ), f_1( b )$ $\ldots$ $f_n( a ), f_n( b )$, then it may be helpful to search $( a = b \vee a \neq b )$ even if $f_i( a )$ and $f_i( b )$ are not equal in $M$ for any $i$.

\paragraph{Implementation}

%We require an efficient method for finding a pair $t, s$ that is maximum with respect to $\succeq$ in $M$, if one exists.
%We describe a method for incrementally maintaining a best fit $s$ for each term $t \mapsto^I \psi$ with respect to $\succeq$.
%In other words, for relevant terms $t \mapsto^I \psi$, we maintain a term $s$ such that $t,s \succeq t,s'$ for all other terms $s'$.
%In doing so, we will easily be able to compute our maximum pair $t,s$ in an efficient manner.

%Our best fit may be changed in two ways: either an equality $t_1 = t_2$ or a disequality $t_1 \neq t_2$ is added in $M$.

[do this] \\

\begin{comment}
Let us now focus our attention to identifying cases in which we can show there \emph{does not} exist instantiations for $\psi$ that lead to conflicts.
By the following lemma, we need only consider the case when all formulas $\psi \in M$ are disequality-compatible in $M$:

\begin{lemma}
For all contexts $M$, there exists a $M'$ such that $M' \models M$, and for all quantified formulas $\psi \in M$, $\psi$ is either equality-compatible or disequality-compatible in $M'$.
\end{lemma}
\begin{proof}
The aforementioned method (as demonstrated in Examples 5 and 6) can be thought of as a constructive proof of this lemma.
For each $\psi$, we split on equalities until all terms $t \mapsto^I \psi$ are equality-compatible, or there exists a term $t \mapsto^I \psi$ such that $t$ is disequality-compatible.
Note that by induction, all instantiation constants $e \mapsto^I \psi$ in $M$ are in non-singleton equivalence classes.
If the equivalence class of $e$ contains no concrete terms, we may introduce a fresh constant $c$ and add this to the equivalence class of $e$ via the splitting lemma $( e = c \vee e \neq c )$.
\end{proof}

\begin{lemma}
Given a consistent set of assertions $M$, if $t \mapsto^I \psi$ is disequality-compatible in $M$, then $M \not\models t[\varepsilon(\bar{e})/\bar{e}] = s'$ for any ground term $s'$.
\end{lemma}
\begin{proof}

\end{proof}

We can claim the following theorem, by noting that the property of term being disequality-compatible gives us the ability to construct a well formed model for quantified formulas.

\begin{thm}
Given a DPLL(T) state $M \parallel F$ where all clauses $F$ are satisfied, say for all asserted formula $(\psi :) \forall \bar{x}. \varphi(\bar{x} )$.
Then, if all quantified formulae $\psi \in M$ are disequality-compatible, then

\end{thm}
\begin{proof}

\end{proof}

The following example shows use of this theorem:

{\bf Example 6}
Say we wish to determine the satisfiability of the set of formulas $S = \{ a \neq b, f( a ) \neq d, (\psi :) \forall \bar{x}. (x = b \Rightarrow f( x ) = d) \}$.
After applying Unit propagation, applying Decide for $\bot^{\neg \psi}$, applying Counterexample $\forall$-Inst, after unit propagation we arrive in the DPLL(T) state $a \neq b, f( a ) \neq d, \neg( \bot^{\neg \psi} )^d, e = b, f( e ) \neq d \parallel S$.
Note that $f( e )$ is disequality combatible since $e \neq a$.
Therefore, by our theorem, $S$ is a satisifiable. \\
\end{comment}

\begin{comment}
\subsection{Counterexample Refinement}

A counterexample state is given by $M \parallel E \parallel P$, where $M$ is the current set of asserted $T$-literals, $E$ is a set of equalities representing the model for our counterexample, and $P$ is a set of equalities that we are currently wishing to add to $E$.
Initially, we start with $M \parallel \bar{s} = \bar{s} \parallel \emptyset$, where $\bar{s}$ is the set of all concrete ground terms.
For a term $t$, we define $V( E, t )$ as either the term $s$ if $t = s \in E$, or NULL otherwise.
For each pair of terms $t,s$, we define the constraint $R( E, t, s )$ as the conjunction of the constraints $\{ . \\

\noindent Decide: \\

$M \parallel E \parallel P \Longrightarrow M, R( E, t, s ) \parallel E, t = s \parallel P$, if   
$\begin{cases}
  \text{ All subchildren of $t$ are in $E$, } \\
  \text{ $t$ is not in $E$, } \\
  M \not\models \neg R( E, t, s ). \\
\end{cases}$ \\

\noindent Suggest: \\

$M, R( E', t, s ) \parallel E, t = s \parallel P \Longrightarrow M \parallel E \parallel P, t = s'$. \\

\noindent Process: \\

$M \parallel E \parallel P, e = s \Longrightarrow M, R( E, e, s ) \parallel E, e = s \parallel P$, if   
$\begin{cases}
  \text{ No term in $E$ contains} \\
  \text{ \ \ \ $e$ as a subchild,} \\
  M \not\models \neg R( E, e, s ). \\
\end{cases}$ \\

$M \parallel E \parallel P, f( \bar{t} ) = f( \bar{s} ) \Longrightarrow M \parallel E \parallel P, \bar{t} = \bar{s}$, if   
$\begin{cases}
  \text{ No term in $E$ contains} \\
  \text{ \ \ \ $f( \bar{t} )$ as a subchild.} \\
\end{cases}$ \\
\end{comment}

\subsection{Search Strategies for LRA}

We assume a theory solver for $LRA$ which maintains a set of inequalities of the form:

\begin{tabular}{rl}
 & $\displaystyle\sum\limits_{i=0}^n C_{i1} \cdot a_i \geq 0$ \\
 & $\vdots$ \\
 & $\displaystyle\sum\limits_{i=0}^n C_{ij} \cdot a_i \geq 0$ \\
 $\displaystyle\sum\limits_{i=0}^m E_{i1} \cdot e_i +$ & $\displaystyle\sum\limits_{i=0}^n D_{i1} \cdot a_i \geq 0$ \\
 & $\vdots$ \\
 $\displaystyle\sum\limits_{i=0}^m E_{ik} \cdot e_i +$ & $\displaystyle\sum\limits_{i=0}^n D_{ik} \cdot a_i \geq 0$ \\
 \end{tabular} \\

where $a_1 \ldots a_n$ are ground constants of type $Real$ and $e_1 \ldots e_m$ are instantiation constants of type $Real$.

[do this]

\subsection{Search Strategies for IDT}

\subsection{Search Strategies for Combined Theories $T$}

\section{Exploring the Counterexample}

In section~\ref{dpll-ce-lit}, we described an approach for handling quantifiers using counterexample literals.
Among the benefits of this approach was recognizing cases when quantified formulas $\forall \bar{x}. \varphi[ \bar{x} ]$ are valid, thus signalling that they do not need to be instantiated further.
In the case that all clauses are satisified and all universally quantified assertions are found to be valid, the solver can answer SAT.

The previous section focused on the opposite goal: we described methods for finding relevant instantiations that are capable of falsifying some or all of the current state.
If this state contains no decision literals and the current state is falsified by our instantiations, we may answer UNSAT.

In this section, we will consider how to proceed in states where a quantified formula $\forall \bar{x}. \varphi[ \bar{x} ]$ is neither valid nor easily shown to be unsatisfiable. \\

{\bf Example 7} 
Say we wish to determine the satisfiability of the set of formulas $S = \{ a = b, (\psi :) \forall x. ((f(x) = c \vee x = a) \Rightarrow x = b) \}$.
After applying Unit Propagation twice, applying Decide on $\neg (\bot^{ \neg \psi })^d$, and applying Counterexample $\forall$-Inst, we obtain the clauses $( \neg \psi \vee \bot^{ \neg \psi } \vee f(e) = c \vee e = a )$ and $( \neg \psi \vee \bot^{ \neg \psi } \vee e \neq b )$.
After unit propagation in the second clause, we obtain $( e \neq b )$.
Now, in the first clause, the solver has a choice which literal to apply Decide to.
Say for the sake of argument we have that the solver chooses to assert $( f(e) = c )^d$.
Here we know that our counterexample must be such that $f( e ) = c$ and $e \neq b$.
We could suggest possible instantiations for $x$, but these may be unhelpful since $e$ is somewhat unconstrained.
However, if we had decided instead to assert $( e = a )^d$, we would immediately have discovered a theory conflict, thus determining that $\psi$ is valid and returning SAT. \\

The previous example illustrates the importance of exploring multiple partial truth assignments for literals involving instantiation constants.
We will formalize a fair search strategy that is capable of reasoning about all possible variations of how counterexamples to universal formulas may look.

\subsection{Enumerating Decisions on Literals with Instantiation Constants}

[do this]

\section{Recognizing Other SAT Instances}

[this section needs work]

\subsection{Decidable Fragments in SMT}

Some approaches to SMT with quantifiers rely on \emph{complete instantiation}, that is, recognizing when a quantified formula $\forall \bar{ x }. \varphi[ \bar{ x } ]$ is a part of a \emph{deciable fragment} of first order logic.
In some cases, a set of ground terms $t_1 \ldots t_n$ is sufficient for instantiating $\forall \bar{ x }. \varphi[ \bar{ x } ]$, and in the case that $\varphi( \bar{ t_1 } ) \wedge \ldots \wedge \varphi( \bar{ t_n } )$ is satisfiable, then $\forall \bar{ x }. \varphi[ \bar{ x } ]$ can be considered valid.

This section describes methods for recognizing other cases where only a finite number of instantiations need be applied to a particular formula $\forall \bar{ x }. \varphi[ \bar{ x } ]$ \emph{within a context $M$}.
These cases are made possible by realizing that in a DPLL(T) state $M \parallel F$, the instantiations required for $\forall \bar{ x }. \varphi[ \bar{ x } ]$ is dependent upon our current assertions $M$.
%In cases where only a finite number of instantiations need be applied to $(\psi:) \forall \bar{ x }. \varphi[ \bar{ x } ]$ in a particular context $M$, we will say $\psi$ is decidable in $M$.  [formalize this in a better way?]

\section{Alternative Implementations}
\label{sec:implementation}

This document has outlined the following suggestions (A1)-(A2) and requirement (A3) for the DPLL(T) solver: \\

\noindent (A1) $(\bot^{\neg \psi})^d$ should never be asserted, \\
(A2) $\neg (\bot^{\neg \psi})^d$ should only be asserted when $\psi^{(d)}$ is asserted, and \\
(A3) if $(\bot^{\neg \psi})^d$ is not asserted, then no literal $l^d$ can be asserted such that $l \mapsto^I \psi$. \\

Ideally, the internal strategies of the SAT-solver should not have to be modified to enforce this schema.
For this reason, we may employ the following alternative recommendations, for which (A1), (A2) and (A3) hold as a consequence.

\subsection{Via Clause Forgetting}

\noindent (B1) For a quantified formula $\psi$, maintain a set $S^\psi$ of all lemmas $C_1, \ldots C_n$ added to $F$ for which $C_i \mapsto^I \psi$, $1 \leq i \leq n$, \\
(B2) When $\psi^{(d)}$ is asserted to $M$, first assert $\neg (\bot^{\neg \psi})^d$ and then add all lemmas $S^\psi$ to $F$, \\
(B3) When $\psi^{(d)}$ removed from $M$, remove each of $S^\psi$ from $F$. \\

Note that (B2) consists of applying Decide (twice) and $n$ applications of $T$-Learn, and (B3) consists of $n$ applications of $T$-Forget.
We know that each of these steps can be executed if we add each lemma in the same order/remove each lemma in the reverse order as it was learned.

This gives us the following improved invariant: \\

{\bf Invariant 1 (Revised)}:
For all DPLL(T) states $M \parallel F$,
(a) all instances of counterexample literals $\bot^{\neg \psi}$ in $F$ reside in clauses of the form $( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}) )$ where if $C(e)$ is unsatisifiable, then $\psi$ is valid, and
(b) if $\psi^{(d)} \not\in M$, then $F$ contains no counterexample literals or literals $l$ such that $l \mapsto^I \psi$. \\

We have that (A1) holds since by Invariant 1(b) (Revised), $\bot^{\neg \psi}$ will only occur in $F$ when $\psi^{(d)}$ is asserted in $M$, and by (B2), only after $\neg (\bot^{\neg \psi})^d$ is asserted.
We have that (A2) holds by (B2) and using similar reasoning.
We have that (A3) also holds similarly to (A1) by noting that literals $l$ such that $l \mapsto^I \psi$ only occur in $F$ when $\psi^{(d)}$ is asserted in $M$.

This implementation scheme requires the ability to remove clauses from the SAT-solver database as well as a special instance of a forced decision.

\begin{comment}
\subsection{Via Controlling Decisions}

\noindent (C1) For a quantified formula $\psi$, maintain a set $L^\psi$ of literals $l_1, \ldots l_n, \bot^{\neg \psi} \in F$ such that $l_i \mapsto^I \psi$, $1 \leq i \leq n$, \\
(C2) When $\psi \not\in M$, mark literals, \\
(C3)
(C4) When $\psi^{(d)}$ is asserted to $M$, assert $\neg (\bot^{\neg \psi})^d$, \\
\end{comment}