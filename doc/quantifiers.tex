\documentclass{llncs}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
%\usepackage{fullpage}
\usepackage{proof}
\usepackage{url}
\usepackage[pdftex]{graphicx}
\usepackage[usenames]{color}
\usepackage{capt-of}

\newtheorem{thm}{Theorem}

\newcommand{\interp}[1]{[ \negthinspace [ #1 ] \negthinspace ]}

\newcommand{\ednote}[1]{{\bf [#1]}\message{ednote!}}


\newcommand{\To}{\Rightarrow}


\begin{document}

\title{Proposal for Handling Quantifiers in SMT}

\author{Andrew Reynolds}
\institute{Computer Science, The University of Iowa, USA}

\date{}

\maketitle
\thispagestyle{empty}

\section{DPLL(T) Approach to Quantifiers}

When extending the DPPL(T) framework to handle formuls involving quantifiers, we rely on the following rules: \\

\noindent $\exists$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \exists \bar{x}. \varphi( \bar{ x } ) \vee \varphi( \bar{ c } )$, if   
$\begin{cases}
  \exists \bar{x}. \varphi( \bar{ x } ) \in M \\
  \bar{ c } \text{ are fresh constants} \\
\end{cases}$ \\

\noindent $\forall$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi( \bar{ x } ) \vee \varphi( \bar{ c } )$, if   
$\begin{cases}
  \forall \bar{x}. \varphi( \bar{ x } ) \in M \\
  \bar{ c } \text{ are ground terms} \\
\end{cases}$ \\

We call the constants introduced in $\exists$-Inst as skolem constants.
Note that in the case of $\exists$-Inst, there is no benefit of instantiating more than once.

Note that the $\forall$-Inst rule always applies in DPLL(T) when a universal quantified formula is asserted, thus restricting the SMT solver from answering SAT.
Typically, repeated applications of $\forall$-Inst are tried until a conflict is discovered, or else the solver returns UNKNOWN.
The main challenges here are (1) determining relevant instantiations to use for the rule $\forall$-Inst, (2) determining when it is no longer worthwhile to apply $\forall$-Inst for a given quantifier, as well as (3) recognizing cases where all necessary instantiation have been tried.

In current approaches, $E$-matching has been used as a method of addressing challenge (1).
More generally, an instantiation method based on matching is the following.
Say we have ground assertions $\l_1 \ldots \l_n$ and quantified assertion $\forall x. \varphi(x)$.
The basic idea behind E-matching is to find a subterm $t$ of $\varphi(x)$, such that $x \in FV( t )$ and a ground term $s$ such that $t[s/x]$ matches some (ground) subterm $t'$ of $l_i$ for some $i$.
For $E$-matching, we say $t_1$ matches $t_2$ if $t_1 = t_2$ modulo a set $E$ of entailed equalities.

Note that based on a particular matching scheme, a \emph{matching loop} may occur, in which ground terms generated by instantiations may lead to matches of a repeating form.
Heuristics have been used to address the challenges of (2), including assigning an instantiation level to each ground term produced as a result of an instantiation.
By giving preference to matches using ground terms of a lower instantiation level, our instantiations effectively can be thought of as a bredth-first search.

The following document reexamines challenges (1)-(3).
Following the recent advances of symbolic model checking, we present a scheme for symbolically reasoning about counterexamples to quantified formulas within the DPLL(T) framework.
Intuitively, for every (universally) quantified formula asserted in a given context, the solver will assume that a counterexample exists, and reason about possible values for this counterexample.

For challenge (1), the goal of this approach will be to leverage theory-specific information to aid in selecting instantiations.
The basic idea is straightforward.
Say we have a universally quantified formula $\forall \bar{x}. \varphi( \bar{x} )$ where $x$ is of a sort belonging to theory $T$.
We introduce a (symbolic) counterexample $\bar{e}$, where $\bar{e}$ are fresh constants, which will correspond to the values for $\bar{x}$ for which $\varphi$ is falsified.
The theory solver for $T$ will suggest instantiations for $\bar{x}$ based on the internal information it has deduced involving $\bar{e}$.
For the theory of $EUF$, this will be roughly equivalent to E-matching.
In addition, when values cannot be found for $\bar{e}$, the solver will know that $\forall \bar{x}. \varphi( \bar{x} )$ is valid, and thus need not apply any more instantiations (and in fact, in some cases may be able to answer SAT).

\subsection{Related Work}

Model-Based Quantifier Instantiation (MBQI) has been proposed as a powerful method for addressing challenge (1).
For a quantified formula $\forall \bar{x}. \varphi(\bar{x})$
The goal of MBQI is to determine relevant instantiations using models to ground clauses in the current context.
More specifically, given a set of clauses $F$, we determine a candidate model $M^n$ for the ground clauses in $F$, as well as other restrictions $R$ on potential models.
For each non-ground clause $C[x] \in F$, we check the satisifiability of $R \wedge \neg C^I[w]$, where $C^I[w]$ is generated by replacing all uninterpretted symbols in $C[x]$ with the interpretation in our model.
In the case that this formula is satisfiable for some $C^I[w]$, we use a model for this formula to instantiate $C[x]$, thereby ruling out a counterexample.
In the case that each of these formulas are unsatisifiable, then we know that our formula is SAT.

However, a major weakness of this approach is that it is not incremental.
In other words, testing the satisfiability of formulas $R \wedge \neg C^I[w]$ comes at a large cost to the solver.
The technique proposed in this document addresses this shortcoming, and can be thought of as an incremental approach to MBQI.

\section{DPLL(T) with Counterexample Literals}
\label{dpll-ce-lit}

In this section, we propose a scheme for reasoning about quantified formulas in SMT within the existing DPLL(T) framework.
This scheme will supplement DPLL(T) with additional rules that provide ways for finding relevant instantiations.

These additions can be done without breaking any currently existing invariants of the DPLL(T) framework, with a few minor exceptions that are cosmetic in nature.
In particular, we will see that all rules currently existing in DPLL(T) remain sound.

\subsection{Counterexample Literals}

Firstly, let us introduce the notion of a counterexample literal.
For a quantified formula $\forall \bar{ x }. \varphi( \bar{ x } )$, its corresponding counterexample literal is formula $(\neg \forall \bar{ x }. \varphi( \bar{ x } ) \Rightarrow \bot)$.
This literal states that ``a counterexample to $\forall \bar{ x }. \varphi( \bar{ x } )$ does not exist", or in other words $\forall \bar{ x }. \varphi( \bar{ x } )$ is valid.
The key idea here is that although this entails the literal $\forall \bar{ x }. \varphi( \bar{ x } )$, we will in a sense trick the SAT-solver into believing they are in fact independent literals.

We will write $\bot^{\neg \psi}$ as shorthand for the counterexample literal $(\neg \psi \Rightarrow \bot)$.

For a DPLL(T) state $M \parallel F$ and for each quantified formula $\psi = \forall \bar{ x }. \varphi( \bar{ x } ) \in M$, we will have three intended configurations for $\psi$ and its counterexample literal $\bot^{\neg \psi}$: \\

(1) $\psi$ is not asserted positively in $M$, 

(2) $\psi^{(d)}$ and $\neg (\bot^{\neg \psi})^d$ are asserted in $M$, 

(3) $\psi$ and $\bot^{\neg \psi}$ are asserted in $M$. \\

Accordingly, we give the following recommendations for the DPLL(T) engine: (A1) \emph{$(\bot^{\neg \psi})^d$ should never be asserted}, and (A2) \emph{ $\neg (\bot^{\neg \psi})^d$ should be asserted immediately after $\psi^{(d)}$ is asserted, and only in such cases}.
Note that neither of these are required for soundness.

In case (1), our configuration does not claim $\psi$ to be true.
In case (2), our configuration has asserted (perhaps as a decision) that $\psi$ is true, but also has decided that it will find a counterexample.
In case (3), our configuration has asserted that $\psi$ is true, and moreover knows that $\psi$ does not have a counterexample.

We will see in the following sections that lemmas of the form $( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}))$ will be added to our set of clauses $F$.
\footnote{ Note that formulas of this form are universally true since $\top \Leftrightarrow ( \neg \psi \vee \bot^{\neg \psi}) \Rightarrow ( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}))$. }
Each of these clauses will say that either $\psi$ does not hold, a counterexample does not exist for $\psi$, or the contraint $C(\bar{e})$ holds for the counterexample $\bar{e}$ of $\psi$,  where $\bar{e}$ are distinguished free constants of the same sorts as $\bar{x}$.
In other words, if there exists a $\bar{t}$ such that $\psi[\bar{t}/\bar{x}]$ is unsatisifiable in $M$, then $C( \bar{t})$ is satisfiable in $M$.
Note the contrapositive: if $C( \bar{e} )$ is unsatisfiable in $M$, then $\psi[\bar{t}/\bar{x}]$ is satisifiable in $M$ for all $\bar{t}$, or in other words, $\psi$ does not have a counterexample and $\psi$ is valid.

Consider the possible states (1)-(3) of our configuration.
In case (1), if $\psi$ is asserted negatively, then the remainder of the clause $( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}))$ is ignored.
In the case of (3), the clause is satisfied by $\bot^{\neg \psi}$ and the solver will again ignore the information contained in $C(\bar{e})$.

More interestingly, in the case of (2), the SAT-solver must find a satisfying assignment for $C(\bar{e})$.
In particular, we will see that this will force the DPLL(T) engine to reason about models for our counterexample $\bar{e}$.
Furthermore, in the case where $C(\bar{e})$ is unsatisifiable, this will signal for the SAT-solver to backjump and assert $\bot^{\neg \psi}$ positively as a non-decision literal, or in other words, a counterexample to $\psi$ cannot exist in the current context.
If this is the case, we are further able to drop the decision annotation from $\psi^{(d)}$ if it exists, and enter into case (3).

Note that applying $\forall$-Inst to $\psi$ in case (3) is futile, since we are sure that a counterexample to $\psi$ cannot exist in the current context.
We will see that this will allow us to answer SAT instead of UNKNOWN in some cases.

\subsection{Instantiation Constants}

In the following, we will use distinguished free constants to refer to the value of a (possibly non-existant) counterexamples.
For convienience, we will refer to such constants as \emph{instantiation constants}, and use $e$ possibly with subscripts to refer to such constants.
Note that for each $e$ of a sort $s$, we allow that $s$ may be interpretted or uninterpretted.

It is important to note that instantiation constants will have identical logical semantics as free constants of the same sort.
In other words, our scheme assumes no information about the value of an instantiation constant $e$, and simply uses this terminology as a way of referring such constants.

We write $e \mapsto^A_i \forall \bar{x}. \varphi( \bar{x} )$ to denote that $e$ is the i$^{th}$ instantiation constant for the formula $\forall \bar{x}. \varphi( \bar{x} ) $, and write $\bar{e} \mapsto^A \forall \bar{x}. \varphi( \bar{x} )$ to denote that $e_1 \mapsto^A_1 \varphi \ldots e_n \mapsto^A_n \forall \bar{x}. \varphi( \bar{x} )$.

%As noted, instantiation constants $\bar{e} \mapsto^A \forall \bar{x}. \varphi( \bar{x} )$ will be used to represent constraints on the logical shape of counterexamples to $\forall \bar{x}. \varphi( \bar{x} )$.
%Roughly speaking, if a model $R, \bar{t}/\bar{e}$ can be found in a current DPLL(T) context, then $\bar{t}$ will be a relevant instantantion for $\forall \bar{x}. \varphi( \bar{x} )$.

We write $l \mapsto^A S$ to denote that $S = \{ \forall \bar{x}. \varphi( \bar{x} ) \mid \exists e \in FV( l ). e \mapsto^A \varphi \}$, or in other words, all instantiation constants in $l$ are from a quantified formula in $S$.
Furthermore write $C \mapsto^A S$ to denote that $S$ is the union of the sets $S_1 \ldots S_n$ for $l_i \in C$, $l_i \mapsto^A S_i$.
A concrete literal (clause) is one that contains no instantiation constants.
We consider a literal (clause) to be pure with respect to quantifiers if it contains instantiation constants from at most one quantified formula.
For convienience, we simply write $E \mapsto^A \forall \bar{x}. \varphi( \bar{x} )$ in the case that expression $E$ contains instantiation constants from exactly one.

\subsection{Counterexample Normal Form for Quantified Formulas}
\label{sec:CENF}

In this section, we present a transformation for quantified formulas, which we will refer to as \emph{counterexample normal form}, or $CexNF$.
Our transformation applied to $\forall \bar{x}. \varphi( \bar{ x } )$ will produce a formula $\psi( \bar{e} )$, such that values $\bar{t}$ for $\bar{e}$ in relevant models will be used to instantiate $\bar{x}$. \\

\noindent $\forall \bar{x}. \varphi( \bar{ x } )$ \\
$\neg \forall \bar{x}. \varphi( \bar{ x } ) \Rightarrow \neg \varphi( \bar{e} )$  where $\bar{e}$ are fresh constants \\
$\neg \forall \bar{x}. \varphi( \bar{ x } ) \Rightarrow (C_1 \wedge \ldots \wedge C_n )$ (CNF conversion of $\neg \varphi( \bar{ e } )$) \\
$\displaystyle\bigwedge\limits_{i=0}^n \neg \forall \bar{x}. \varphi( \bar{ x } ) \Rightarrow C_i$. \\
$\displaystyle\bigwedge\limits_{i=0}^n \bot^{\neg \forall \bar{x}. \varphi( \bar{ x } )} \vee C_i$ \\

We will consider $\bar{e}$ as instantiation constants for $\bar{x}$.
Note that literals in $C_i$ may represent quantifiers.

\begin{thm}
The counterexample normal of a formula $\psi( \bar{e} ) = CexNF( \forall \bar{x}. \varphi( \bar{ x } ) )$ for $\bar{e} \mapsto^A \forall \bar{x}. \varphi( \bar{ x } )$ has the following properties:
(a) $\forall \bar{x}. \varphi( \bar{ x } ) \Rightarrow \psi( \bar{e} )$,
(b) for all contexts $M$, if there exists $\bar{t}$ such that $\varphi( \bar{t} )$ is unsatisfiable, then there exists a model $R$ for $\psi$ for which $R( \bar{e} ) = \bar{t}$, and
(c) all quantified formulas over $\bar{x}$ in $\psi$ reside in counterexample literals. \\
\end{thm}

{\bf Example 0}
Consider the formula $\psi = \forall x. (l_1 \vee (( l_2 \vee x = a \vee x = b ) \Rightarrow x \neq c))$.
Its counterexample normal form is $( \neg l_1 \vee \bot^{\neg \psi}) \wedge ( l_2 \vee e = a \vee e = b \vee \bot^{\neg \psi} ) \wedge ( e = c \vee \bot^{\neg \psi})$. \\

In Example 0, we have produced three clauses.
The first says that either $l_1$ is false or a counterexample does not exist to $\psi$.
The second says that either $l_2$ is true, a counterexample $\psi[e/x]$ exists such that $e$ is equal to $a$ or $b$, or a counterexample does not exist to $\psi$. 
Similarly, the third says that either a counterexample $\psi[e/x]$ exists such that $e$ is equal to $c$, or one does not exist.

\subsection{Counterexample $\forall$-Inst}

The transformation described in Section~\ref{sec:CENF} can be used to introduce clauses containing instantiation constants into the DPLL(T) framework.
Conceptually, the following rule constructs a lemma that describes a counterexample $\bar{e}$ for the universally quantified formula $\forall \bar{x}. \varphi( \bar{ x } )$, and adds it as a lemma to $F$.
This rule represents the central idea behind our approach: \\

\noindent Counterexample $\forall$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi( \bar{ x } ) \vee \varphi'( \bar{ e } )$, if   
$\begin{cases}
  \forall \bar{x}. \varphi( \bar{ x } ) \in M \\
  \varphi'( \bar{ e } ) = CexNF( \forall \bar{x}. \varphi( \bar{ x } ) ) \\
  \bar{ e } \mapsto^A \forall \bar{x}. \varphi( \bar{ x } ) \\
\end{cases}$ \\

Note that by Theorem 1(a), this rule is clearly sound.

Let us again consider Example 0.
By applying Counterexample $\forall$-Inst to $\psi$, we will produce three clauses $C_1, C_2, C_3$ after CNF-conversion:

$C_1 : ( \neg \psi \vee \bot^{\neg \psi} \vee \neg l_1)$,

$C_2 : ( \neg \psi \vee \bot^{\neg \psi} \vee l_2 \vee e = a \vee e = b )$, and

$C_3 : ( \neg \psi \vee \bot^{\neg \psi} \vee e = c )$.

After we force the SMT solver to assert $\neg( \bot^{\neg \varphi} )^d$, it can be shown that the default behavior of DPLL(T) is sufficient and desirable for reasoning about clauses containing counterexample literals and literals with instantiation constants.

Let us first consider when we are in a state $M, \psi, \neg( \bot^{\neg \varphi} )^d, N \parallel F$, were $\psi$ has been asserted as a non-decision literal and its counterexample literal has been decided upon negatively.

In the case that $l_1$ is asserted positively (possibly as a decision) in $M = M_1, l^{(d)}_1, M_2$, we have that $C_1$ is falsified and we will backjump to the state $M, \psi, \bot^{\neg \varphi} \parallel F$.
This corresponds to saying that a counterexample cannot exist to $\psi$ in the context $M$ where $l_1$ is true.

In the case that $l_1$ is asserted positively as a decision literal in $N = N_1, l^d_1, N_2$, we have that $C_1$ is falsified and we will backjump to the state $M, \psi, \neg( \bot^{\neg \varphi} )^d,$ $N_1, \neg l_1$ $\parallel F$.
This corresponds to saying that $l_1$ must be false if a counterexample to $\psi$ exists.
Note here that we are preferring to constrain ourselves to states in which a counterexample is more likely to occur.
This makes sense, both semantically since we have decided that a counterexample may exist (i.e. $\neg( \bot^{\neg \varphi} )^d$), and operationally since the DPLL(T) will reach a non-terminating state if it cannot prove that a counterexample exists.

In the case that $l_1$ is asserted positively as a non-decision literal in $N = N_1, l_1, N_2$, we have that $C_1$ is falsified and conflict analysis should proceed in the standard way to backjump to a state of the form $M, \psi, \neg( \bot^{\neg \varphi} )^d, N' \parallel F$ or $M, \psi, \neg( \bot^{\neg \varphi} )  \parallel F$.
In the former case, we have determined that some decision in $N_1$ has led us to require $l_1$ to be true thereby conflicting with our decision that a counterexample exists.
In the latter case, we have determined that assuming a counterexample exists means that $l_1$ must be true and thus a counterexample cannot exist.
\footnote{ While this behavior is desirable, this case will never occur due to Invariant 1.}

Now consider the case where we are in a state $M, \psi^d, \neg( \bot^{\neg \varphi} )^d, N  \parallel F$ where now $\psi$ has been asserted as a decision literal.

The cases here are identical with one notable exception.
Take the case where we have encountered a conflict and backjumped to the state $M, \psi^d, \bot^{\neg \varphi} \parallel F$, that is, we know that $\psi$ does not have a counterexample.
Note the lemma $(\neg (\bot^{\neg \psi}) \vee \psi)$, that is, either $\psi$ has a counterexample or is $\psi$ is true.
If this clause were in $F$, we could apply Backjump with $C' \vee l' = \neg (\bot^{\neg \psi}) \vee \psi$ to arrive at the state $M, \psi \parallel F$.
Note, however that this lemma is exactly what we \emph{do not} want to tell the SAT-solver, as it encodes the trick of our approach.
Thus, we must perform this Backjump implicitly, as will be shown in the next section in the rule \emph{Counterexample Backjump} [do this].

The analysis for $C_2$ and $C_3$ are similar, where now the DPLL(T) engine may give partial truth assignments to $e = a$, $e = b$ and $e = c$ which will be useful for determining instantiations.
Note in the context $M, \psi, \neg( \bot^{\neg \varphi} )^d$, the literal $e = c$ will be unit propagated within $C_3$, thereby signalling that we should only be searching for counterexamples where $e = c$.
Moreover, it is easy to see that $c$ is the \emph{only} instantiation we need to try for $x$ in this example.

We formally define the following invariant for DPLL(T):

{\bf Invariant 1}:
For all DPLL(T) states $M \parallel F$, all instances of counterexample literals $\bot^{\neg \psi}$ in $F$ occur in clauses of the form $( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}) )$ where if $C(e)$ is unsatisifiable, then $\psi$ is valid. \\

Note that by Theorem 1, the Counterexample $\forall$-Inst maintains Invariant 1.
In addition, since counterexample literals $\bot^{ \neg \psi }$ have no meaning apart from representing boolean values, no lemma added to $F$ by $T$-Learn will contain a counterexample literal.
[do this: What about boolean learning?]

\subsection{Enhancements for DPLL(T) Rules}

First, let us revisit the rule for $\forall$-Inst.
Note that we may restrict this rule to only be applicable to formulas $\forall \bar{x}. \varphi( \bar{ x } )$ in cases where a counterexample can exist to $\forall \bar{x}. \varphi( \bar{ x } )$.

We first must note the following restriction to our DPLL(T) engine: (A3) \emph{if $\psi^{(d)}$ is not asserted, then no literal $l$ where $l \mapsto^A \psi$ can be asserted}.
We will see a recommended implementation in Section~\ref{sec:implementation} which handles this restriction explicitly and without modification to the core of the SAT solver.

Consider the case when $\bot^{\neg \forall \bar{x}. \varphi( \bar{ x } )}$ occurs as a non-decision literal in $M$.
By Invariant 1, this necessarily entails that $\psi$ is valid in the current context.
Our updated rule becomes the following: \\

\noindent $\forall$-Inst (Counterexample Restricted): \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi( \bar{ x } ) \vee \varphi( \bar{ c } )$, if   
$\begin{cases}
  \forall \bar{x}. \varphi( \bar{ x } ) \in M \\
  \bar{ c } \text{ are ground terms} \\
  \bot^{\neg \forall \bar{x}. \varphi( \bar{ x } )} \text{ is not asserted positively }\\
  \text{ \ \ \ as a non-decision literal in $M$ } \\    
\end{cases}$ \\

Note that these restrictions are helpful when trying to establish a satisifiable instance of a formula involving quantifiers.
The following example shows an instance where the solver may return SAT by determining that a counterexample cannot exist to a universally quantified formula in a particular context.

{\bf Example 1}
Say we wish to determine the satisifiability of the set of formulas $S = \{ a = b, (\psi :) \forall x. ((f(x) = a \wedge f(x) \neq b) \Rightarrow l) \}$.
After two applications of Decide, we arrive in the DPLL(T) state $( a = b )^d, \psi^d \parallel S$.
After using Counterexample $\forall$-Inst, our state becomes $( a = b )^d, \psi^d \parallel (S':) S \cup \{ (\neg \psi \vee \bot^{\neg \psi} \vee f( e ) = a), (\neg \psi \vee \bot^{\neg \psi} \vee f( e ) \neq b)), (\neg \psi \vee \bot^{\neg \psi} \vee \neg l) \}$.
We now claim that the DPLL(T) should counter-intuitively decide that $\psi$ has a counterexample, and our state becomes $( a = b )^d, \psi^d, \neg (\bot^{\neg \psi})^d \parallel S'$. 
After unit propagation our state becomes $\ldots, f( e ) = a, f( e ) \neq b, \neg l \parallel S'$, and we encounter the EUF theory conflict $a = b, f( e ) = a, f( e ) \neq b \models \bot$.
After conflict analysis, we will backtrack to the state $( a = b )^d, \psi^d, (\bot^{\neg \psi}) \parallel S'$, and now notice that all clauses in $S'$ are satisfied and $\forall$-Inst does not apply to $\psi$.
The solver answers SAT. \\

Here, we have determined $S$ is satisfiable by noting that any model where $a = b$ is true also satisfies $\psi$ for all possible values for $x$.

It is also important to note that learned lemmas can involve instantiation constants.
In this example, after the theory conlifct, we could have added the lemma $(\varphi : ) ( f( e ) \neq a \vee f( e ) = b \vee a \neq b )$ to $S'$.
In this case, we may apply Decide to come to the state $( a = b )^d, \psi^d, (\bot^{\neg \psi}), (f( e ) \neq a)^d \parallel S' \cup \varphi$, where again all clauses are satisfied, and the solver answers SAT in the same manner.

However, note that the lemma $\varphi$ is only useful in contexts in which $(\psi :) \forall x. ((f(x) = a \wedge f(x) \neq b) \Rightarrow l)$ is asserted.
In other words, the solver should not be searching for values of counterexamples to quantified formulas $\psi$ when $\psi$ is not asserted.
We will see in Section~\ref{sec:implementation} a recommended implementation for which this concern is addressed.

%For this reason, we \emph{weaken all learned lemmas involving instantiation constants}.
%In particular, if we learn a clause $C$, we weaken this clause to $C \vee \neg \forall \bar{x_1}. \varphi_1 \vee \ldots \vee \neg \forall \bar{x_n}. \varphi_n$ where $C \mapsto^A \{ \forall \bar{x_1}. \varphi_1 \ldots \forall \bar{x_n}. \varphi_n \}$ before adding it to $F$.
%In this case, our lemma becomes $(\varphi' :) ( f( e ) \neq a \vee f( e ) = b \vee a \neq b \vee \neg \psi )$.

\section{Theory Specific Matching Using Instantiation Constants}
\label{sec:theory-matching}

In this section, we describe effecient methods for computing relevant instantiations from theory solvers.
Abstractly, we wish to find a method $Match_T( M, \bar{ e } )$ for theory $T$ in context $M$ that returns a ground substitution $s$, where the domain of $s$ is equal to $\bar{ e }$.
For $\bar{ e } \mapsto^A \forall \bar{x}. \varphi( \bar{x} )$ and substitution $s = \{ \bar{t}/\bar{e} \}$, we will apply the $\forall$-Inst rule to $\forall \bar{x}. \varphi( \bar{x} )$ to obtain $\varphi( \bar{t} )$.
In other words, we wish to use the following more specified version of $\forall$-Inst: \\

\noindent $\forall$-Inst (Counterexample Restricted, Matching): \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi( \bar{ x } ) \vee \varphi( \bar{ t } )$, if   
$\begin{cases}
  \forall \bar{x}. \varphi( \bar{ x } ) \in M \\
  \bar{ e } \mapsto^A \forall \bar{x}. \varphi( \bar{ x } ), \ \bar{ x } \text{ belong to $T$ } \\
  Match_T( M, \bar{ e } ) = \bar{ t } \\
  \bot^{\neg \forall \bar{x}. \varphi( \bar{ x } )} \text{ is not asserted positively }\\
  \text{ \ \ \ as a non-decision literal in $M$ } \\
\end{cases}$ \\

Note that no restrictions will be placed on $Match_T( M, \bar{ e } )$. 
A very native implementation of $Match_T$ would be to chose an arbitrary ground substitution for any input.
However, it may be the case that theory solvers contain information that is pertinent for defining useful $Match_T$ methods.
In particular, a theory's decision procedure can determine relevant values for instantiation constants in possible models.
The remainder of this section will focus on such theories.

%The basic idea behind each theory matching algorithm is as follows:
%Say the theory solver has deduced theory literals $l$ and $l'( \bar{e} )$, where $l$ is concrete and $l'$ contains abstract constants $\bar{e} \mapsto^A \forall \bar{x}. \varphi( \bar{ x } )$.
%The instantantion $\bar{ t }$ will be considered relevant for $\forall \bar{x}. \varphi( \bar{ x } )$ if there exists (possibly multiple) pairs $( l, l' )$, where $l$ is similar to $l'[\bar{ t }\slash \bar{e}]$ according to some metric.

The intuition here is straightforward: for a (proper) theory predicate $P$, if $P(e)$ holds where $e$ is an instantiation constant, then our instantiation $t$ for $e$ should be such that $P( t )$ has a maximum likelihood to hold.
For example, let us consider the case of the theory $EUF$ the predicate $=_c$ for a ground constant $c$ where $=_c( t )$ holds if and only if $t$ is in the same equivalence class as $c$.
If $=_c( e )$ holds for an instantiation constant $e \mapsto^A \forall x. \varphi$, then it is advantageous to try the instantiation $\forall x. \varphi[c/x]$, futile to try any $\forall x. \varphi[t/x]$ such that $t \neq c$, and possibly helpful to try $\forall x. \varphi[t/x]$ such that $t = c$ is satisfiable.
We will see that more powerful predicates should be used for $EUF$, including those implicitly used by $E$-matching.

It is important to note that in the DPLL(T) search we branch on literals involving instantiation constants.
Thus, at any given point we are searching for only one possibility of how a counterexample $\bar{e}$ to a quantified formula $\psi$ must look.
Our $Match_T$ methods will behave locally, in that they will only be concerned with finding instantiations that are relevant given the current assumptions about $\bar{e}$.
Section~\ref{sec:search-strategies} will examine fair strategies for how to explore all possibilities of counterexamples to quantified formulas.

\subsection{$Match_{EUF}$}

We begin with a few motivating examples.

{\bf Example 2}
Consider the set of asserted literals $M = \{ f( a, c ) = d, f( c, a ) = b, d = a, (\psi :) \forall xy. (f( x, y ) = a \Rightarrow f( y, x ) \neq b), \neg ( \bot^{\neg \psi} )^d \}$.
After applying Counterexample $\forall$-Inst to $\psi$ and after unit propagation, we will obtain $M' = M \cup \{ (f( e_1, e_2 ) = a), (f( e_2, e_1 ) = b) \}$ where $e_1, e_2 \mapsto^A \psi$.
In $M'$, the $EUF$-solver can deduce the pairs $( f( a, c ) = a, f( e_1, e_2 ) = a )$ and $( f( c, a ) = b,  f( e_2, e_1 ) = b )$.
Here, we can immediately see that $a, c$ is a relevant instantiation for $x, y$ by noticing the fact that for each pair $( l, l')$, we have that $l$ is syntactically equivalent to $l'$ for the substitution $\{ e_1 \rightarrow a, e_2 \rightarrow c \}$.
By applying $\forall$-Inst, we obtain the lemma $(\neg \forall xy. (f( x, y ) = a \Rightarrow f( y, x ) \neq b) \vee ( f( a, c ) = a \Rightarrow f( c, a ) \neq b ))$, which after propagating gives us a contradiction. \\

{\bf Example 3} 
Say we wish to determine the satisfiability of the formula $(\psi :) \forall x, y. ( y = c \Rightarrow x \neq y )$.
In a similar manner to Example 2, we will arrive in the DPLL(T) state $\psi^d, (\bot^{ \neg \psi })^d, e_1 = c, e_1 = e_2 \parallel S \cup \ldots$.
Here we have that $e_1 = e_2 = c$, thus we should try the instantiation $\{ x \rightarrow c, y \rightarrow c \}$, giving us the contradiction $( c = c \Rightarrow c \neq c )$ after instantiation of $\psi$. \\

Example 3 shows the importance of knowing theory-specific information about the relationships between instantiation constants.  
In this example, it was noted that in order for a counterexample to $\psi$ to exist, an instantiation must be such that $x = y$.

In this section, we describe an efficient method for $Match_{EUF}$, which is capable of determining relavant instanatiations for the theory of equality and uninterpretted function symbols (EUF) in a given context $M$.
Note that the relevance of these instantations depends on the set of theory literals currently asserted in $M$ to the $EUF$ theory solver, where $M$ contains both (1) equalities and disequalities between ground (concrete) terms, and (2) equalities and disequalities between terms involving instantiation constants.

We assume a theory solver for $EUF$ which maintains a set of equivalence classes $E_1 \ldots E_n$ and set $D$ of disequalities between these equivalence classes.  
We write $D( E_i, E_j )$ to denote that there exists a disequality between equivalence classes $E_i$ and $E_j$.

[do this]


%The method described in this section can be thought of as an improvement to $E$-matching.
%Spoken in terms of $Match_{EUF}$, $E$-matching amounts to finding a instantiantion $\bar{ t }/\bar{ x }$, such that the following hold: 
%(1) there exists a (concrete) EUF term $t_c$ in an equivalence class $E_i$,
%(2) there exists an abstract term $t_a$ in some equivalence class $E_j$ where all abstract constants $e \in FV( t_a )$ are such that $e \mapsto_A \forall \bar{ x }. \varphi( \bar{ x } )$, and
%(3) there exists a $t' \in E_i$ such that $t_a[\bar{t}/\bar{e}]$ is syntactically equivalent to $t'$.
%Note that this disregards the logical structure of the counterexample for $\forall \bar{ x }. \varphi( \bar{ x } )$ in the current context, and as such does not guarentee that $\bar{ t }/\bar{ x }$ will rule out any relevant counterexamples.

We claim that the relevant subset of substitutions $E$-matching produces can be thought of as a special case of $Match_{EUF}$.
That is, $Match_{EUF}$ is equivalent to $E$-matching if we restrict ourselves to use the metric $( l, l'[ \bar{ t }/\bar{ e }]  )$ are similar if $l$ and $l'[ \bar{ t }/\bar{ e }]$ share a common subterm $t$.
[do this]

\subsection{$Match_{LRA}$}

We assume a theory solver for $LRA$ which maintains a set of inequalities of the form:

\begin{tabular}{rl}
 & $\displaystyle\sum\limits_{i=0}^n C_{i1} \cdot a_i \geq 0$ \\
 & $\vdots$ \\
 & $\displaystyle\sum\limits_{i=0}^n C_{ij} \cdot a_i \geq 0$ \\
 $\displaystyle\sum\limits_{i=0}^m E_{i1} \cdot e_i +$ & $\displaystyle\sum\limits_{i=0}^n D_{i1} \cdot a_i \geq 0$ \\
 & $\vdots$ \\
 $\displaystyle\sum\limits_{i=0}^m E_{ik} \cdot e_i +$ & $\displaystyle\sum\limits_{i=0}^n D_{ik} \cdot a_i \geq 0$ \\
 \end{tabular} \\

where $a_1 \ldots a_n$ are ground constants of type $Real$ and $e_1 \ldots e_m$ are instantiation constants of type $Real$.

[do this]

\subsection{$Match_{IDT}$}

\subsection{$Match_{T}$ for Combined Theories $T$}

\section{Strategies for Searching}

In section~\ref{dpll-ce-lit}, we described an approach for handling quantifiers using counterexample literals.
Among the benefits of this approach was recognizing cases when quantified formulas $\forall \bar{x}. \varphi( \bar{x} )$ are valid, thus signalling that they do not need to be instantiated further.
In the case that all clauses are satisified and all universally quantified assertions are found to be valid, the solver can answer SAT.

Section~\ref{sec:theory-matching} focused primarily on the opposite goal: we described methods for finding relevant instantiations that are likely to falsify the current state.
After (ideally a small number of) instantatiations of the form $\varphi( \bar{c_1} ) \ldots \varphi( \bar{c_n} )$, we hope to find a state where a ground clause or a clause produced by these instantiations is falsified.
If this state contains no decision literals, we may answer UNSAT.

In this section, we will consider how to proceed in states where a quantified formula $\forall \bar{x}. \varphi( \bar{x} )$ is neither valid nor easily shown to be unsatisfiable. \\

{\bf Example 4} 
Say we wish to determine the satisfiability of the set of formulas $S = \{ a = b, (\psi :) \forall x. ((f(x) = c \vee x = a) \Rightarrow x = b) \}$.
After applying Decide twice, applying Decide on $\neg (\bot^{ \neg \psi })^d$, and applying Counterexample $\forall$-Inst, we obtain the clauses $( \neg \psi \vee \bot^{ \neg \psi } \vee f(e) = c \vee e = a )$ and $( \neg \psi \vee \bot^{ \neg \psi } \vee e \neq b )$.
After unit propagation in the second clause, we obtain $( e \neq b )$.
Now, in the first clause, the solver has a choice which literal to apply Decide to.
Say for the sake of argument we have that the solver chooses to assert $( f(e) = c )^d$.
Here we know that our counterexample must be such that $f( e ) = c$ and $e \neq b$.
We could suggest possible instantiations for $x$, but these may be fruitless since $e$ is somewhat unconstrained.
However, if we had decided instead to assert $( e = a )^d$, we would immediately have discovered a theory conflict, thus determining that $\psi$ is valid and returning SAT. \\

The previous example illustrates the importance of exploring multiple partial truth assignments for literals involving instantiation constants.
We will formalize a fair search strategy that is capable of reasoning about all possible variations of how counterexamples to universal formulas may look.

\subsection{Enumerating Decisions on Literals with Instantiation Constants}

[do this]

\section{Recognizing Other SAT Instances}

[this section needs work]

\subsection{Decidable Fragments in SMT}

Some approaches to SMT with quantifiers rely on \emph{complete instantiation}, that is, recognizing when a quantified formula $\forall \bar{ x }. \varphi( \bar{ x } )$ is a part of a \emph{deciable fragment} of first order logic.
In some cases, a set of ground terms $t_1 \ldots t_n$ is sufficient for instantiating $\forall \bar{ x }. \varphi( \bar{ x } )$, and in the case that $\varphi( \bar{ t_1 } ) \wedge \ldots \wedge \varphi( \bar{ t_n } )$ is satisfiable, then $\forall \bar{ x }. \varphi( \bar{ x } )$ can be considered valid.

This section describes methods for recognizing other cases where only a finite number of instantiations need be applied to a particular formula $\forall \bar{ x }. \varphi( \bar{ x } )$ \emph{within a context $M$}.
These cases are made possible by realizing that in a DPLL(T) state $M \parallel F$, the instantiations required for $\forall \bar{ x }. \varphi( \bar{ x } )$ is dependent upon our current assertions $M$.
%In cases where only a finite number of instantiations need be applied to $(\psi:) \forall \bar{ x }. \varphi( \bar{ x } )$ in a particular context $M$, we will say $\psi$ is decidable in $M$.  [formalize this in a better way?]

%For example, if $M$ is empty, then recognition of complete fragments is identical to previously existing approaches.
%In the case where $M$ is unsatisifiable, then every quantified formula $\psi$ is decidable in $M$, since it suffices to not instantiate $\psi$ at all.

The idea will be to recognize cases when $Match_T$ cannot suggest any helpful instantiations, thereby suggesting that a quantifier does not have a counterexample.
Consider the following trivial example.

{\bf Example 5}
Say we wish to determine the satisfiability of the set of formulas $S = \{ a = b, (\psi :) \forall \bar{x}. (f( x ) = a \vee l) \}$.
After applying Decide twice, applying Decide for $\bot^{\neg \psi}$, applying Counterexample $\forall$-Inst, and Unit propagation, we arrive in the DPLL(T) state $(a=b)^d, \psi^d, \neg ( \bot^{\neg \psi} )^d, f( e ) \neq a \parallel S \cup \ldots$.
We can claim that no instantiation for $e$ is useful, since we can create a model in which every term that does not involve instantiation constants is equal to $a$, and moreover $f(e)$ must be disequal from $a$.

\subsection{Completeness in a Context $M$}

[do this]

\section{Recommended Implementation}
\label{sec:implementation}

This document has outlined the following suggestions (A1)-(A2) and requirement (A3) for the DPLL(T) solver: \\

\noindent (A1) $(\bot^{\neg \psi})^d$ should never be asserted, \\
(A2) $\neg (\bot^{\neg \psi})^d$ should be asserted immediately after $\psi^{(d)}$ is asserted and only in such cases, and \\
(A3) if $\psi^{(d)}$ is not asserted, then no literal $l$ where $l \mapsto^A \psi$ can be asserted. \\

Ideally, the internal strategies of the SAT-solver should not have to be modified to enforce this schema.
For this reason, we may employ the following alternative recommendations (B1)-(B3), for which (A1), (A2) and (A3) hold as a consequence: \\

\noindent (B1) Maintain a mapping $S$ from quantified formulas $\psi$ and the set of all lemmas $S(\psi) = \{ C_1, \ldots C_n \}$ added to $F$ for which $C_i \mapsto^A \psi$, $1 \leq i \leq n$, \\
(B2) When $\psi^{(d)}$ is asserted to $M$, first assert $\neg (\bot^{\neg \psi})^d$ and then add all lemmas $S(\psi)$ to $F$, \\
(B3) When $\psi^{(d)}$ removed from $M$, remove each of $S(\psi)$ from $F$. \\

Note that (B2) consists of applying Decide (twice) and $n$ applications of $T$-Learn, and (B3) consists of $n$ applications of $T$-Forget.
We know that each of these steps can be executed if we add each lemma in the same order/remove each lemma in the reverse order as it was learned.

This gives us the following improved invariant: \\

{\bf Invariant 1 (Revised)}:
For all DPLL(T) states $M \parallel F$,
(a) all instances of counterexample literals $\bot^{\neg \psi}$ in $F$ reside in clauses of the form $( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}) )$ where if $C(e)$ is unsatisifiable, then $\psi$ is valid, and
(b) if $\psi^{(d)} \not\in M$, then $F$ contains no counterexample literals or literals $l$ such that $l \mapsto^A \psi$. \\

We have that (A1) holds since by Invariant 1(b) (Revised), $\bot^{\neg \psi}$ will only occur in $F$ when $\psi^{(d)}$ is asserted in $M$, and by (B2), only after $\neg (\bot^{\neg \psi})^d$ is asserted.
We have that (A2) holds by (B2) and using similar reasoning.
We have that (A3) also holds similarly to (A1) by noting that literals $l$ such that $l \mapsto^A \psi$ only occur in $F$ when $\psi^{(d)}$ is asserted in $M$.

\end{document}

