\documentclass{llncs}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{comment}
%\usepackage{fullpage}
\usepackage{proof}
\usepackage{url}
\usepackage[pdftex]{graphicx}
\usepackage[usenames]{color}
\usepackage{capt-of}

\newtheorem{thm}{Theorem}
\newtheorem{cor}{Corollary}

\newcommand{\interp}[1]{[ \negthinspace [ #1 ] \negthinspace ]}

\newcommand{\ednote}[1]{{\bf [#1]}\message{ednote!}}


\newcommand{\To}{\Rightarrow}


\begin{document}

\title{Counterexample-Based Quantifier Instantiation for SMT}

\author{Andrew Reynolds}
\institute{Computer Science, The University of Iowa, USA}

\date{}

\maketitle
\thispagestyle{empty}

\section{DPLL(T) Approach to Quantifiers}

When extending the DPPL(T) framework to handle formuls involving quantifiers, we rely on the following rules: \\

\noindent $\exists$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \exists \bar{x}. \varphi( \bar{ x } ) \vee \varphi( \bar{ c } )$, if   
$\begin{cases}
  \exists \bar{x}. \varphi( \bar{ x } ) \in M \\
  \bar{ c } \text{ are fresh constants} \\
\end{cases}$ \\

\noindent $\forall$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi( \bar{ x } ) \vee \varphi( \bar{ s } )$, if   
$\begin{cases}
  \forall \bar{x}. \varphi( \bar{ x } ) \in M \\
  \bar{ s } \text{ are ground terms} \\
\end{cases}$ \\

We call the constants introduced in $\exists$-Inst as skolem constants.
Note that in the case of $\exists$-Inst, there is no benefit of instantiating more than once.

Note that the $\forall$-Inst rule always applies in DPLL(T) when a universal quantified formula is asserted, thus restricting the SMT solver from answering SAT.
Typically, repeated applications of $\forall$-Inst are tried until a conflict is discovered, or else the solver returns UNKNOWN.
The main challenges here are (1) determining relevant instantiations to use for the rule $\forall$-Inst, (2) determining when it is no longer worthwhile to apply $\forall$-Inst for a given quantifier, as well as (3) recognizing cases where all necessary instantiations have been tried.

In current approaches, $E$-matching has been used as a method of addressing challenge (1).
An instantiation method based on matching is the following.
Say we have ground assertions $\l_1 \ldots \l_n$ and quantified assertion $\forall x. \varphi(x)$.
The idea is to find a subterm $t$ of $\varphi(x)$, such that $x \in FV( t )$ and a ground term $s$ such that $t[s/x]$ matches some (ground) subterm $t'$ of $l_i$ for some $i$.
For $E$-matching, we say $t_1$ matches $t_2$ if $t_1 = t_2$ modulo a set $E$ of entailed equalities.

Note that based on a particular matching scheme, a \emph{matching loop} may occur, in which ground terms generated by instantiations may lead to matches of a repeating form.
Heuristics have been used to address the challenges of (2), including assigning an instantiation level to each ground term produced as a result of an instantiation.
By giving preference to matches using ground terms of a lower instantiation level, our instantiations effectively can be thought of as a bredth-first search.

With regards to challenge (3), some SMT solvers employ what is known as \emph{complete instantiation} when dealing with quantifiers.
If the solver can recognize that the body of a quantifier occurs in a decidable fragment of first order logic, then the solver may only need to try a finite number of instantiations before either finding a contradiction or determining the quantified formula is valid.
In the cases where the formula is found to be valid, then the solver may be able to answer SAT.

The following document reexamines challenges (1)-(3).
Following the recent advances of symbolic model checking, we present a scheme for symbolically reasoning about counterexamples to quantified formulas within the DPLL(T) framework.
Intuitively, for every (universally) quantified formula asserted in a given context, the solver will assume that a counterexample exists, and reason about possible values for this counterexample.

For challenge (1), the goal of this approach will be to leverage theory-specific information to aid in selecting instantiations.
The basic idea is straightforward.
Say we have a universally quantified formula $\forall \bar{x}. \varphi( \bar{x} )$ where $x$ is of a sort belonging to theory $T$.
We introduce fresh constants $\bar{e}$ to represent the possible values for $\bar{x}$ for which $\varphi$ is falsified.
The theory solver for $T$ will suggest instantiations for $\bar{x}$ based on the internal information it has deduced involving $\bar{e}$.
For the theory of $EUF$, this will be roughly equivalent to E-matching.
In addition, when values cannot be found for $\bar{e}$, the solver will know that $\forall \bar{x}. \varphi( \bar{x} )$ is valid, and thus need not apply any more instantiations, and in some cases may be able to answer SAT.

\subsection{Related Work}

Model-Based Quantifier Instantiation (MBQI) has been proposed as a powerful method for addressing challenges (1) and (3).
For a quantified formula $\forall \bar{x}. \varphi(\bar{x})$
The goal of MBQI is to determine relevant instantiations using models to ground clauses in the current context.
More specifically, given a set of clauses $F$, we determine a candidate model $M^n$ for the ground clauses in $F$, as well as other restrictions $R$ on potential models.
For each non-ground clause $C[x] \in F$, we check the satisifiability of $R \wedge \neg C^I[w]$, where $C^I[w]$ is generated by replacing all uninterpretted symbols in $C[x]$ with the interpretation in our model $M^n$.
In the case that this formula is satisfiable for some $C^I[w]$, we use a model for this formula to instantiate $C[x]$, thereby ruling out the counterexample.
In the case that each of these formulas $R \wedge \neg C^I[w]$ are unsatisifiable, then we know that our formula is SAT.

However, a weakness of this approach is that it is not incremental.
In other words, testing the satisfiability of formulas $R \wedge \neg C^I[w]$ potentially comes at a large cost to the solver.

The technique proposed in this document takes an opposite approach to quantifier instantiation.
We extend DPLL(T) to incrementally reason about \emph{counterexamples} to quantified formulae.
Based on possible values for our counterexample, our procedure will construct instantiations that are likely to be relevant in the current context, as well as decide when no helpful instantiations exist.
Moreover, if we show that the value of a counterexample to $\psi$ in unsatisifiable in the current context, then we have shown that $\psi$ is valid and need not be instantiated.

\section{DPLL(T) with Counterexample Literals}
\label{dpll-ce-lit}

In this section, we propose a scheme for reasoning about quantified formulas in SMT within the existing DPLL(T) framework.
This scheme will supplement DPLL(T) with additional rules that provide ways for finding relevant instantiations.

These additions can be done without breaking any currently existing invariants of the DPLL(T) framework, with a few minor exceptions that are cosmetic in nature.
In particular, we will see that all rules currently existing in DPLL(T) remain sound.

\subsection{Counterexample Literals}

Firstly, let us introduce the notion of a counterexample literal.
For a quantified formula $\forall \bar{ x }. \varphi( \bar{ x } )$, its corresponding counterexample literal is formula $(\neg \forall \bar{ x }. \varphi( \bar{ x } ) \Rightarrow \bot)$.
This literal states that ``a counterexample to $\forall \bar{ x }. \varphi( \bar{ x } )$ does not exist", or in other words $\forall \bar{ x }. \varphi( \bar{ x } )$ is valid.
The key idea here is that although this entails the literal $\forall \bar{ x }. \varphi( \bar{ x } )$, we will in a sense trick the SAT-solver into believing they are in fact independent literals.

We will write $\bot^{\neg \psi}$ as shorthand for the counterexample literal $(\neg \psi \Rightarrow \bot)$.

For a DPLL(T) state $M \parallel F$ and for each quantified formula $\psi = \forall \bar{ x }. \varphi( \bar{ x } ) \in M$, we have three intended configurations for $\psi$ and its counterexample literal $\bot^{\neg \psi}$: \\

(1) $\psi$ is not asserted positively in $M$, 

(2) $\psi^{(d)}$ and $\neg (\bot^{\neg \psi})^d$ are asserted in $M$, 

(3) $\psi$ and $\bot^{\neg \psi}$ are asserted in $M$. \\

Accordingly, we give the following recommendations for the DPLL(T) engine: (A1) \emph{$(\bot^{\neg \psi})^d$ should never be asserted}, and (A2) \emph{ $\neg (\bot^{\neg \psi})^d$ should only be asserted when $\psi^{(d)}$ is asserted}.
Note that neither of these are required for soundness.

In case (1), our configuration does not claim $\psi$ to be true.
In case (2), our configuration has asserted (perhaps as a decision) that $\psi$ is true, but also has decided that it will find a counterexample.
In case (3), our configuration has asserted that $\psi$ is true, and moreover knows that $\psi$ does not have a counterexample.

We will see in the following sections that lemmas of the form $( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}))$ will be added to our set of clauses $F$.
\footnote{ Note that formulas of this form are universally true since $\top \Leftrightarrow ( \neg \psi \vee \bot^{\neg \psi}) \Rightarrow ( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}))$. }
Each of these clauses will say that either $\psi$ does not hold, a counterexample does not exist for $\psi$, or the contraint $C(\bar{e})$ holds for the counterexample $\bar{e}$ of $\psi$,  where $\bar{e}$ are distinguished free constants of the same sorts as $\bar{x}$.
In other words, if there exists a $\bar{t}$ such that $\psi[\bar{t}/\bar{x}]$ is unsatisifiable in $M$, then $C( \bar{t})$ is satisfiable in $M$.
Note the contrapositive: if $C( \bar{e} )$ is unsatisfiable in $M$, then $\psi[\bar{t}/\bar{x}]$ is satisifiable in $M$ for all $\bar{t}$, or in other words, $\psi$ does not have a counterexample and $\psi$ is valid.

Consider the possible states (1)-(3) of our configuration.
In case (1), if $\psi$ is asserted negatively, then the remainder of the clause $( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}))$ is ignored.
In the case of (3), the clause is satisfied by $\bot^{\neg \psi}$ and the solver will again ignore the information contained in $C(\bar{e})$.

More interestingly, in the case of (2), the SAT-solver must find a satisfying assignment for $C(\bar{e})$.
In particular, we will see that this will force the DPLL(T) engine to reason about models for our counterexample $\bar{e}$.
Furthermore, in the case where $C(\bar{e})$ is unsatisifiable, this will signal for the SAT-solver to backjump and assert $\bot^{\neg \psi}$ positively as a non-decision literal, or in other words, a counterexample to $\psi$ cannot exist in the current context.
If this is the case, we are further able to drop the decision annotation from $\psi^{(d)}$ if it exists, and enter into case (3).

Note that applying $\forall$-Inst to $\psi$ in case (3) is futile, since we are sure that a counterexample to $\psi$ cannot exist in the current context.
We will see that this will allow us to answer SAT instead of UNKNOWN in some cases.

\subsection{Instantiation Constants}

In the following, we will use distinguished free constants to refer to the value of a (possibly non-existant) counterexamples.
For convienience, we will refer to such constants as \emph{instantiation constants}, and use $e$ possibly with subscripts to refer to such constants.
Note that for each $e$ of a sort $s$, we allow that $s$ may be interpretted or uninterpretted.

It is important to note that instantiation constants will have identical logical semantics as free constants of the same sort.
In other words, our scheme assumes no information about the value of an instantiation constant $e$, and simply uses this terminology as a way of referring such constants.

We write $e \mapsto^I_i \forall \bar{x}. \varphi( \bar{x} )$ to denote that $e$ is the i$^{th}$ instantiation constant for the formula $\forall \bar{x}. \varphi( \bar{x} ) $, and write $\bar{e} \mapsto^I \forall \bar{x}. \varphi( \bar{x} )$ to denote that $e_1 \mapsto^I_1 \varphi \ldots e_n \mapsto^I_n \forall \bar{x}. \varphi( \bar{x} )$.

For a literal $l$, we write $l \mapsto^I S$ to denote that $S = \{ \forall \bar{x}. \varphi( \bar{x} ) \mid \exists e \in l. e \mapsto^I \forall \bar{x}. \varphi( \bar{x} ) \}$, or in other words, all instantiation constants in $l$ refer to a quantified formula in $S$.
Furthermore write $C \mapsto^I S$ to denote that $S$ is the union of the sets $S_1 \ldots S_n$ for $l_i \in C$, $l_i \mapsto^I S_i$.
A concrete literal (clause) is one that contains no instantiation constants.
We consider a literal (clause) to be pure with respect to quantifiers if it contains instantiation constants from at most one quantified formula.
For convienience, we simply write $E \mapsto^I \forall \bar{x}. \varphi( \bar{x} )$ in the case that expression $E$ contains instantiation constants from exactly one.
An expression $E$ is \emph{concrete} if $E \mapsto^I \emptyset$.

\subsection{Counterexample Lemmas for Quantified Formulas}
\label{sec:CENF}

In this section, we present a particular type of lemma for quantified formulas, which we will refer to as the \emph{counterexample lemma} for a quantified formula.
The counterexample lemma of a formula $\forall \bar{x}. \varphi( \bar{ x } )$ is defined to be $\bot^{\neg \forall \bar{x}. \varphi( \bar{x} )} \vee \neg \varphi( \bar{e} )$, where $\bar{e} \mapsto^I \forall \bar{x}. \varphi( \bar{x} )$.
This formula is valid since:

\begin{tabular}{llll}
$\neg \forall \bar{x}. \varphi( \bar{ x } )$ & $\Rightarrow$ & $\exists \bar{x}. \neg \varphi( \bar{x} )$ \\
$\neg \forall \bar{x}. \varphi( \bar{ x } )$ & $\Rightarrow$ & $\neg \varphi( \bar{e} )$  & where $\bar{e}$ are fresh constants \\
$\bot^{\neg \forall \bar{x}. \varphi( \bar{x} )}$ & $\vee$ & $\neg \varphi( \bar{e} )$. \\
\end{tabular}

We will consider $\bar{e}$ as instantiation constants for $\bar{x}$.
Note that $\varphi(\bar{e})$ may contain quantifiers.

{\bf Example 0}
Consider the formula $\psi = \forall x. (l_1 \vee (( l_2 \vee x = a \vee x = b ) \Rightarrow x \neq c))$.
Its counterexample lemma after conversion to CNF is $( \neg l_1 \vee \bot^{\neg \psi}) \wedge ( l_2 \vee e = a \vee e = b \vee \bot^{\neg \psi} ) \wedge ( e = c \vee \bot^{\neg \psi})$. \\

In Example 0, we have produced three clauses.
The first says that either $l_1$ is false or a counterexample does not exist to $\psi$.
The second says that either $l_2$ is true, a counterexample $\psi[e/x]$ exists such that $e$ is equal to $a$ or $b$, or a counterexample does not exist to $\psi$. 
Similarly, the third says that either a counterexample $\psi[e/x]$ exists such that $e$ is equal to $c$, or one does not exist.

\subsection{Counterexample $\forall$-Inst}

The transformation described in Section~\ref{sec:CENF} can be used to introduce clauses containing instantiation constants into the DPLL(T) framework.
Conceptually, the following rule constructs a lemma that describes a counterexample $\bar{e}$ for the universally quantified formula $\forall \bar{x}. \varphi( \bar{ x } )$, and adds it as a lemma to $F$.
This rule represents the central idea behind our approach: \\

\noindent Counterexample $\forall$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi( \bar{x} ) \vee \bot^{\neg \forall \bar{x}. \varphi( \bar{x} )} \vee \neg \varphi( \bar{ e } )$, if   
$\begin{cases}
  \forall \bar{x}. \varphi( \bar{ x } ) \in M \\
  \bar{ e } \mapsto^I \forall \bar{x}. \varphi( \bar{ x } ) \\
\end{cases}$ \\

Since we only care about finding a counterexample for $\forall \bar{x}. \varphi( \bar{x} )$ when it is asserted, we add its negation into the disjunction of the counterexample lemma for $\forall \bar{x}. \varphi( \bar{x} )$.
Clearly, this rule is sound since $\bot^{\neg \forall \bar{x}. \varphi( \bar{x} )} \vee \neg \varphi( \bar{ e } )$ is tautological.

Let us again consider Example 0.
By applying Counterexample $\forall$-Inst to $\psi$, we will produce three clauses $C_1, C_2, C_3$ after CNF-conversion:

$C_1 : ( \neg \psi \vee \bot^{\neg \psi} \vee \neg l_1)$,

$C_2 : ( \neg \psi \vee \bot^{\neg \psi} \vee l_2 \vee e = a \vee e = b )$, and

$C_3 : ( \neg \psi \vee \bot^{\neg \psi} \vee e = c )$.

If we force the SMT solver to assert $\neg( \bot^{\neg \varphi} )^d$, it can be shown that the default behavior of DPLL(T) is sufficient and desirable for reasoning about clauses containing counterexample literals and literals with instantiation constants.

Let us first consider when we are in a state $M, \psi, \neg( \bot^{\neg \varphi} )^d, N \parallel F$, were $\psi$ has been asserted as a non-decision literal and its counterexample literal has been decided upon negatively.

In the case that $l_1$ is asserted positively (possibly as a decision) in $M = M_1, l^{(d)}_1, M_2$, we have that $C_1$ is falsified and we will backjump to the state $M, \psi, \bot^{\neg \varphi} \parallel F$.
This corresponds to saying that a counterexample cannot exist to $\psi$ in the context $M$ where $l_1$ is true.

In the case that $l_1$ is not asserted in $M$, we will apply Unit Propagation to $C_1$ and arrive in the state $M, \psi, \neg( \bot^{\neg \varphi} )^d, \neg l_1$ $\parallel F$.
This corresponds to saying that $l_1$ must be false if a counterexample to $\psi$ exists.
Note here that we are preferring to constrain ourselves to states in which a counterexample may occur.
This makes sense, both semantically since we have decided that a counterexample may exist (i.e. $\neg( \bot^{\neg \varphi} )^d$), and operationally since the DPLL(T) will reach a non-terminating state if it cannot prove that a counterexample exists.

Otherwise, if $l_1^d$ had been asserted positively as a decision in $N$, $C_1$ is falsified and conflict analysis would proceed in the standard way to backjump to a state of the form $M, \psi, \neg( \bot^{\neg \varphi} )^d, N', \neg l_1 \parallel F$ or $M, \psi, \neg( \bot^{\neg \varphi} )  \parallel F$.
In the former case, we have determined that some decision in $N$ has led us to require $l_1$ to be true thereby conflicting with our decision that a counterexample exists.
In the latter case, we have determined that assuming a counterexample exists means that $l_1$ must be true and thus a counterexample cannot exist.

Now consider the case where we are in a state $M, \psi^d, \neg( \bot^{\neg \varphi} )^d, N  \parallel F$ where now $\psi$ has been asserted as a decision literal.

The cases here are identical with one notable exception.
Take the case where we have encountered a conflict and backjumped to the state $M, \psi^d, \bot^{\neg \varphi} \parallel F$, that is, we know that $\psi$ does not have a counterexample.
Note the lemma $(\neg (\bot^{\neg \psi}) \vee \psi)$, that is, either $\psi$ has a counterexample or $\psi$ holds.
We can apply Backjump with $C' \vee l' = \neg (\bot^{\neg \psi}) \vee \psi$ to arrive at the state $M, \psi \parallel F$.
Note, however that this lemma should not be added $F$, as it is exactly what we \emph{do not} want to tell the SAT-solver, as it encodes the trick of our approach.

The analysis for $C_2$ and $C_3$ are as expected, where now the DPLL(T) engine may give partial truth assignments to $e = a$, $e = b$ and $e = c$ which will be useful for determining instantiations.
Note in the context $M, \psi, \neg( \bot^{\neg \varphi} )^d$, the literal $e = c$ will be unit propagated within $C_3$, thereby signalling that we should only be searching for counterexamples where $e = c$.
Moreover, it is easy to see that $c$ is the \emph{only} instantiation we need to try for $x$ in this example.

We formally define the following invariants for DPLL(T): \\

{\bf Invariant 1}:
For all DPLL(T) states $M \parallel F$, the only instance of literal $\bot^{\neg \psi}$ in $F$ occur in clauses $C_1 \ldots C_n$ such that $C_1 \ldots C_n$ is logically equivalent to $( \neg \psi \vee \bot^{\neg \psi} \vee \neg \psi[\bar{e}/\bar{x} )$ where $\bar{e} \mapsto^I \bar{x}$.

{\bf Invariant 2}:
For all DPLL(T) states $M \parallel F$, all clauses $C \mapsto^I \psi$ in $F$ are tautological. \\

By definition, counterexample $\forall$-Inst maintains Invariants 1 and 2.
In addition, since counterexample literals $\bot^{ \neg \psi }$ have no meaning apart from representing boolean values, no lemma added to $F$ by $T$-Learn will violate Invariant 1.
[do this: Boolean Learning?]

\subsection{Representation of Counterexamples}

It is important to note that in the DPLL(T) search we branch on literals involving instantiation constants.
Thus, at any given point we are searching for only one possibility of how a counterexample to a quantified formula $\psi$ can look.
In this section, we describe precisely what is said about our counterexample to $\psi$.

We say a DPLL(T) state $M \parallel F$ is \emph{candidate-satisifiable} if all clauses in $F$ are satisified and $M$ is $T$-consistent.
We say a quantified formula $\psi \in M$ is \emph{counterexample-active} in $M \parallel F$ if Counterexample $\forall$-Inst has been applied to $\psi$ and $\neg (\bot^{\neg \psi})^d \in M$.
The following theorem tells us what formulas are asserted for counterexample-active $\psi$ in candidate-satisifiable DPLL(T) states:

\begin{thm}
\label{thm:cerep}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$ and a quantified formula $\psi \in M$ whose DNF-conversion is $\forall \bar{x}. (S_1 \vee \ldots \vee S_n)$.
If $\psi$ is counterexample-active in $M \parallel F$, then $\neg l_1 [\bar{e}/\bar{x}] \ldots \neg l_n [\bar{e}/\bar{x}] \in M$ where $\bar{e} \mapsto^I \psi$, for some $l_1 \in S_1, \ldots l_n \in S_n$.
\end{thm}
\begin{proof}
Say $(\psi :) \ \forall \bar{x}. (S_1 \vee \ldots \vee S_n)$ is asserted in $M$, Counterexample $\forall$-Inst has been applied to $\psi$ and $\neg (\bot^{\neg \psi}) \in M$.
By definition of Counterexample $\forall$-Inst, we have added the lemma $( \neg \psi \vee \bot^{\neg \psi} \vee \neg (S_1 \vee \ldots \vee S_n )[\bar{e}/\bar{x}] )$ where $\bar{e} \mapsto^I \psi$.
Thus $F \models \displaystyle\bigwedge\limits_{i=1}^n ( \neg \psi \vee \bot^{\neg \psi} \vee \displaystyle\bigvee\limits_{l_j \in S_i} \neg l_j[\bar{e}/\bar{x}])$.
Since $\psi$ and $\neg \bot^{\neg \psi}$ are asserted in $M$, at least one literal of the form $l_i[\bar{e}/\bar{x}]$ is asserted negatively in $M$ for each $S_i$ containing $l_i$. $\Box$
\end{proof}

\subsection{Enhancements for DPLL(T) Rules}

First, let us revisit the rule for $\forall$-Inst.
Note that we may restrict this rule to only be applicable to formulas $\forall \bar{x}. \varphi( \bar{ x } )$ in cases where a counterexample can exist to $\forall \bar{x}. \varphi( \bar{ x } )$.
Such cases can be easily recognized due to the following theorem:

\begin{thm}
For all DPLL(T) states of the form $M, \bot^{\neg \psi}, M' \parallel F$, if no literal $l \mapsto^I \psi$ is asserted as a decision in $M$, then $\psi[\bar{t}/\bar{x}]$ is tautological in $M, \bot^{\neg \psi}, M'$ for all $\bar{t}$.
\end{thm}
\begin{proof}
Assume we have a DPLL(T) state $M, \bot^{\neg \psi}, M' \parallel F$, where $\bot^{\neg \psi}$ is asserted as a non-decision literal.

\begin{comment}
Say that $\psi$ has DNF-conversion $\forall \bar{x}. (S_1 \vee \ldots \vee S_n)$, and thus $F \models \displaystyle\bigwedge\limits_{i=1}^n ( \neg \psi \vee \bot^{\neg \psi} \vee \displaystyle\bigvee\limits_{l_j \in S_i} \neg l_j[\bar{e}/\bar{x}])$.
By Invariant 1, the literal $\bot^{\neg \psi}$ only occurs in such clauses in $F$.

Consider the case where $\bot^{\neg \psi}$ was asserted by unit-propagation.
Then $M \models \neg ( \neg \psi \vee \displaystyle\bigvee\limits_{l_j \in S_i} \neg l_j[\bar{e}/\bar{x}] )$ for some $S_i$.
We know that $\psi \in M$, and since no literal $l \mapsto^I \psi$ is asserted as a decision in $M$, we know that there exists an $M' \subseteq M$ such that $M'$ does not contain $\bar{e}$, and $M', F' \models \neg \displaystyle\bigvee\limits_{l_j \in S_i} \neg l_j[\bar{e}/\bar{x}]$, where $F' \subseteq F$ is the set of (tautological) clauses containing $\bar{e}$.
Therefore, we know that $M' \models \forall \bar{x}. S_i$ (since $\bar{e} \not\in M'$) and thus $\psi[\bar{t}/\bar{x}]$ is tautological in $M' \subseteq M$.

Consider the case where $\bot^{\neg \psi}$ was asserted due to a backjump.
\end{comment}
[do this] $\Box$
\end{proof}

We add the following restriction to our DPLL(T) engine: (A3) \emph{if $(\bot^{\neg \psi})^d$ is not asserted, then no literal $l^d$ can be asserted such that $l \mapsto^I \psi$}.
We will see an alternative implementation in Section~\ref{sec:implementation} which handles this restriction explicitly and without modification to the SAT solver.

Our updated rule for $\forall$-Inst becomes the following: \\

\noindent $\forall$-Inst (Counterexample Restricted): \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi( \bar{ x } ) \vee \varphi( \bar{ c } )$, if   
$\begin{cases}
  \forall \bar{x}. \varphi( \bar{ x } ) \in M \\
  \bar{ c } \text{ are \emph{concrete} ground terms} \\
  \bot^{\neg \forall \bar{x}. \varphi( \bar{ x } )} \text{ is not asserted positively }\\
  \text{ \ \ \ as a non-decision literal in $M$ } \\    
\end{cases}$ \\

Note that these restrictions are helpful when trying to establish a satisifiable instance of a formula involving quantifiers.
The following example shows an instance where the solver may return SAT by determining that a counterexample cannot exist to a universally quantified formula in a particular context. \\

{\bf Example 1}
Say we wish to determine the satisifiability of the set of formulas $S = \{ a = b, (\psi :) \forall x. ((f(x) = a \wedge f(x) \neq b) \Rightarrow l) \}$.
After two applications of Unit Propagation, we arrive in the DPLL(T) state $( a = b ), \psi \parallel S$.
After using Counterexample $\forall$-Inst, our state becomes $( a = b ), \psi \parallel (S':) S \cup \{ (\neg \psi \vee \bot^{\neg \psi} \vee f( e ) = a), (\neg \psi \vee \bot^{\neg \psi} \vee f( e ) \neq b)), (\neg \psi \vee \bot^{\neg \psi} \vee \neg l) \}$.
We now claim that the DPLL(T) should counter-intuitively decide that $\psi$ has a counterexample, and our state becomes $( a = b ), \psi, \neg (\bot^{\neg \psi})^d \parallel S'$. 
After unit propagation our state becomes $\ldots, f( e ) = a, f( e ) \neq b, \neg l \parallel S'$, and we encounter the EUF theory conflict $a = b, f( e ) = a, f( e ) \neq b \models \bot$.
After conflict analysis, we will backtrack to the state $( a = b ), \psi, (\bot^{\neg \psi}) \parallel S'$, and now notice that all clauses in $S'$ are satisfied and $\forall$-Inst does not apply to $\psi$.
The solver answers SAT. \\

Here, we have determined $S$ is satisfiable by noting that any model where $a = b$ is true also satisfies $\psi$ for all possible values for $x$.

It is also important to note that learned lemmas can involve instantiation constants.
In this example, after the theory conlifct, we could have added the lemma $(\varphi_1 : ) ( f( e ) \neq a \vee f( e ) = b \vee a \neq b )$ to $S'$.
In this case, we may apply Decide to come to the state $( a = b ), \psi, (\bot^{\neg \psi}), (f( e ) \neq a)^d \parallel S' \cup \varphi$, where again all clauses are satisfied, and the solver answers SAT in the same manner.

However, note that the lemma $\varphi_1$ is only useful in contexts in which $\psi$ is asserted.
In other words, the solver should not be searching for values of counterexamples to quantified formulas $\psi$ when $\psi$ is not asserted.
We will see in Section~\ref{sec:implementation} a recommended implementation for which this concern is addressed.
[do this: do these lemmas pollute the DPLL(T) space?  When should we forget them?  Should we give them to minisat?]
[do this: examine elaborating lemmas involving instantiation constants as being lemmas involving universal statements, justify as well]

\section{Search Strategies for Quantifier Instantiation}

In this section, we describe search methods for determining relevant instantiations using theory-specific information we have deduced about instantiation constants $\bar{e}$.
Our goal will be to find states $M \parallel F$ in which we can construct a concrete ground instantiation $\bar{s}$ for some quantified formula $\psi \in M$ such that $\psi [\bar{s}/\bar{x}]$ \emph{must be} unsatisfiable in $M$.

We begin with the following definitions:
Given a quantified formula $\psi$ that is counterexample-active in $M \parallel F$, $\psi$ is \emph{instantiation-ready in $M'$} if and only if $M \subseteq M'$, $M'$ is $T$-consistent and for all $e_i \mapsto^I \psi$ in $M'$, we have that $M' \models_T (e_i = t_i)$ for some concrete ground term $t_i$.
For an instantiation-ready quantified formula $\psi$, define $\varepsilon_{M'}( \bar{e} )$ for $\bar{e} \mapsto^I \psi$ as a vector of concrete ground terms $t_1 \ldots t_n$ such that if $e_i$ is in $M'$, then $M' \models_T (e_i = t_i)$.
%For instantiation-ready $\psi$, we call $\psi$ instantiation-potent in $M$ if $\bar{e} = \varepsilon_M( \bar{e} ) \models M \mid_\psi$.

The following theorem describes cases when we can construct a useful instantiation:

\begin{thm}
\label{thm:instready}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, for all quantified formula $\psi \in M$, if $\psi$ is instantiation-ready in $M'$ where $M \subseteq M'$, then $\psi[\varepsilon_{M'}( \bar{e} )/\bar{x}]$ is $T$-unsatisfiable in $M'$, where $\bar{e} \mapsto^I \psi$.
\end{thm}
\begin{proof}
Consider the quantified formula $\psi \in M$ whose DNF conversion is $\forall \bar{x}. S_1 \vee \ldots \vee S_n$, where $S_1 \ldots S_n$ are conjunctions of $T$-literals.
Assume $\psi$ is instantiation-ready in $M'$ where $M \subseteq M'$, and that $\bar{e} = \bar{e_1} \cup \bar{e_2}$, where $\bar{e_1}$ are in $M'$ and $\bar{e_2}$ are not in $M'$.
Note by Theorem~\ref{thm:cerep}, literals $\neg l_1 [\bar{e_1}/\bar{x_1}] \ldots \neg l_n [ \bar{e_1}/\bar{x_1} ]$ are asserted in $M$ for some $l_1 \in S_1, \ldots l_n \in S_n$, where $\bar{x_1}$ are the corresponding variables of $\psi$ for $\bar{e_1}$.

Using proof by contradiction, let us assume that $\psi[\varepsilon_{M'}( \bar{e} )/\bar{x}]$ is $T$-satisfiable in $M'$, and thus $S_i[\varepsilon_{M'}( \bar{e} )/\bar{x}]$ is $T$-satisifiable for some $i$.
Since $S_i[\varepsilon_{M'}(\bar{e})/\bar{x}]$ is $T$-satisfiable in $M'$, then $l_i[\varepsilon_{M'}( \bar{e} )/\bar{x}]$ is $T$-satisifiable as well.
Note that $M' \models_T (\varepsilon_{M'}(\bar{e_1}) = \bar{e_1}) \wedge \neg l_i[\bar{e_1}/\bar{x_1}]$ and therefore $M' \models_T \neg l_i[\varepsilon_{M'}(\bar{e})/\bar{x}]$.
This means that $l_i[\varepsilon_{M'}(\bar{e})/\bar{x}]$ is $T$-unsatisifiable in $M'$, and that $S_i[\varepsilon_{M'}(\bar{e})/\bar{x}]$ is $T$-unsatisfiable in $M'$ for all $i$.

Therefore, $\psi[\varepsilon_{M'}( \bar{e} )/\bar{x}]$ is $T$-unsatisfiable in $M'$. $\Box$
\end{proof}

\begin{cor}
\label{cor:instready}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, for all quantified formula $\psi \in M$,
if $\psi$ is instantiation-ready in $M'$ where $M \subseteq M'$, then the instantiation clause $( \neg \psi$ $\vee$ $\psi[\varepsilon_{M'}( \bar{e} )/\bar{x}])$ has not been added to $F$.
\end{cor}
\begin{proof}
The proof is immediate, noting that by Theorem~\ref{thm:instready}, $( \neg \psi \vee \psi[\varepsilon_{M'}( \bar{e} )/\bar{x}])$ is $T$-unsatisifiable in $M'$, and therefore cannot be satisfied in $M \parallel F$. $\Box$
\end{proof}

In other words, Theorem~\ref{thm:instready} states that if we can find a state $M'$ in which we have solved for values of all instantiation constants for $\psi$, we can construct an instantiation for $\psi$ that leads to a conflict in $M'$.
Corollary~\ref{cor:instready} states that if we can find such an instantiation, then it has not yet been applied.
This fact guarentees that no redundant instantiations are used in our instantiation scheme.

\begin{comment}
Now, let us focus on identifying states in which there does not exist any useful instantiations with regards to assumptions about our counterexample.
The basic idea is to find a literal $\l \mapsto^I \psi$ in $M$ such that $\forall \bar{x}. \neg l[\bar{x}/\bar{e}]$ is satisifiable in $M$.
We call such a literal to be $\emph{compatible}$ in $M$.
For example, a EUF literal $f( t_1, \ldots, t_n ) = s$ is compatible if for all terms of the form $f( s_1, \ldots, s_n )$, we have that $t_1 \neq s_1, \ldots t_n \neq s_n$.
That is, the domain of $f( t_1, \ldots, t_n )$ is disjoint from all other terms with top symbol $f$.

Given a theory $T$, we will define search method that will drive the DPLL(T) search with splitting lemmas of the form $( l \vee \neg l )$.
The idea is to chose such lemmas such that the DPLL(T) search will either reach a state $M \parallel F$ such that $\psi$ is instantiation-ready in $M$, or there exists some literal $l \mapsto^I \psi$ that is compatible in $M$.
\end{comment}

We will describe search strategies for instantiations in terms of transition relations $\rightarrow$ between sets of assertions.
We call a set of assertions $M$ \emph{terminal for quantifier instantiation with repect to $P$} if one of the following hold:

(1) $M$ is $T$-inconsistent,

(2) there exists a $\psi \in M$ that is instantiation-ready, or

(3) $P(M)$ holds. \\

A relation $\rightarrow$ is \emph{terminiating for quantifier instantiation with respect to $P$} if there does not exist an infinite chain between sets of assertions $M \rightarrow M_1 \rightarrow \ldots,$ such that $M, M_1, \ldots$ are non-terminal for quantifier instantiation with respect to $P$.

Define the set of instantiations $Inst( \rightarrow, M )$ as $\{ [\varepsilon_{M'}(\bar{e})/\bar{x}] \mid \exists M'. \ M \rightarrow^\ast M', \psi \ is \ instantiation \ ready \ in \ M', \bar{e} \mapsto^I \psi \}$.
A relation $\rightarrow$ \emph{logically complete} if $\bigvee \{ M' \backslash M \mid M \rightarrow M' \}$ is a tautology.
Note that by Theorem~\ref{thm:instready}, a candidate-satisfiable state $M \parallel F$ is in conflict if there exists a relation $\rightarrow$ that is logically complete and terminating for quantifier instantiation with respect to $P$, and there does not exist a $M'$ such that $M \rightarrow^\ast M'$ and $P(M)$ holds.
Here, $P$ represents a termination condition for our search, or in other words, $P(M)$ holds when we decide that it is no longer useful for search for instantiations.

Our search strategies collect sets of relevant instantiations $Inst( \rightarrow, M )$ that are used for generating instantiation clauses.
We use the following rule for $\forall$-Inst, now with the specification of how our instantiations are constructed: \\

\noindent $\forall$-Inst (Counterexample Restricted, Instantiation Search): \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi( \bar{ x } ) \vee \varphi( \bar{ s } )$, if   
$\begin{cases}
  [\bar{ s }/\bar{e}] \in Inst( \rightarrow, M ), \bar{e} \mapsto^I \forall \bar{x}. \varphi( \bar{ x } ), \\
  \bot^{\neg \forall \bar{x}. \varphi( \bar{ x } )} \text{ is not asserted positively }\\
  \text{ \ \ \ as a non-decision literal in $M$ } \\    
\end{cases}$ \\

\ \\

It is recommended that all instantiations computed by $Inst( \rightarrow, M )$ are applied at the same time.
Depending on the strategy used, a large or small number of instantiations may be generated.
In the case in which no instantiations are generated, the SMT solver must either answer unknown, or backtrack and reverse some decision $l^d$ to $\neg l^d$.

It may also be helpful to add learned lemmas in cases in which our instantiation search reaches $T$-inconsistent states $M'$, as such lemmas will help prune the search space of subsequent searches.

As a naive approach, one could use an incomplete search strategy $\rightarrow$ for guessing instantiations for $\psi$, such that $M \rightarrow M'$ if and only if $M' = M, (e = t)$ for some $e \mapsto^I \psi$ that is not equal to any ground term.
In this approach, $t$ represents a guess for $e$.

%Define the termination predicate $P_{\mid Inst \mid = n}$ as 

%We will define a terminating search strategy $\rightarrow_\psi$ by the use of splitting literals $l^\psi_M$.
%Define the relation $\rightarrow_{\psi+}$ between sets of assertions such that $M \rightarrow_{\psi+} M'$ if and only if $M' = M, l^\psi_M$, and similarly $M \rightarrow_{\psi-} M'$ if and only if $M' = M, \neg l^\psi_M$.
%Define the relation $M \rightarrow_\psi M'$ as $\rightarrow_{\psi+} \cup \rightarrow_{\psi-}$. 

\subsection{Search Strategy for Quantifier Instantiation in EUF}

We begin with a motivating example: \\

{\bf Example 3}
Consider the set of clauses $S = \{ (\psi :)\forall x. (f( x ) = x) \wedge f( f( a ) ) \neq a \}$.  Note that this formula is unsatisifiable.
After applying unit propagation twice, Counterexample $\forall$-Inst, decide on $\neg \bot^{\neg \psi}$, after unit propagation we arrive at the DPLL(T) state $f( f( a ) ) \neq a, \psi, \neg (\bot^{\neg \psi})^d, f(e) \neq e \parallel (S':)S \cup \{ ( \neg \psi \vee \bot^{\neg \psi } \vee f( e ) \neq e ) \}$.
Note that $M \parallel F$ is candidate-satisfiable and $\psi$ is not instantiation-ready. \\

The idea behind our instantiation search in EUF is to resolve ambiguity between concrete ground terms and terms with instantiation constants with the same top symbol.
In Example 3, we do not know whether $f( f( a ) )$ and $f( e )$ represent the same term, since conceptually the value of the (potential) counterexample $e$ to $\psi$ is undetermined.
We will see that this will cause our search procedure add the splitting lemma $( e = f( a ) \vee e \neq f( a ) )$, for which $\psi$ is instantiation-ready in the former case.

First, we begin with the following terminology.
A term $f( t_1, \ldots, t_n ) \mapsto^I \psi$ is \emph{equality-compatible with term $s$ in $M$} if and only if $s$ is of the form $f( s_1, \ldots s_n )$ and $M \models_T t_1 = s_1 \wedge \ldots \wedge t_n = s_n$.
Similarly, a term $t \mapsto^I \psi$ is \emph{equality-independent from term $s$ in $M$} if: 

(1) $t := f( t_1, \ldots, t_n )$, and $s := g( s_1, \ldots s_m )$, or
 
(2) $t := f( t_1, \ldots, t_n )$, $s := f( s_1, \ldots s_n )$ in $M$, and $M \models_T t_i \neq s_i$ for some $i$. 

For a term $t \mapsto^I \psi$, $t$ is simply \emph{equality-independent in $M$} if $t$ is equality-independent from all other terms $s \in M$.  
A pair of terms of the form $t, s$ is \emph{equality-ambiguous} if $t$ is neither equality-compatible nor equality-independent from $s$.
For an equality-ambiguous pair of terms $t := f( t_1, \ldots, t_n )$, $s := f( s_1, \ldots s_n )$, we define $NArgs( t, s )$ as the number of arguments of $t$ and $s$ such that $M \models (t_i = s_i)$, and $NArgs'( t, s )$ as the number of arguments of $t$ and $s$ such that $M \not\models (t_i = s_i)$

We will define a search strategy that leads to states $M'$ in which some quantified formula $\psi \in M'$ is instantiation-ready, or that for each $\psi \in M'$, some $t \mapsto^I \psi$ is equality-independent in $M'$.

We first informally describe the strategy in general terms and discuss the heuristics we use for guiding our search.
As eluded to, the idea behind our search is to find equality-ambiguous pairs of terms $t, s$ where $t \mapsto^I \psi$ and add splitting lemmas that either will drive $t$ to be equality-compatible or equality-independent from $s$.
We prefer pairs $t, s$ where $t \mapsto^I \psi$ is not an instantiation constant.

Given $t \mapsto^I \psi$ is not an instantiation constant, we prefer pairs $t, s$ such that $s$ is a concrete ground term with maximum likelihood that $t$ is equal to $s$ in a real counterexample.
For this purpose, we first prefer $s$ such that $M \models_T t = s$, then those in which $M \not\models_T t \neq s$.
In the latter case, we may prefer $s$ such that $M \models_T t \neq c_1 \neq \ldots \neq c_n \neq s$, with a minimal length $n \geq 2$.
As secondary and tertiary heuristics, we chose $s$ such that $NArgs'( t, s )$ is minimized, and pairs that where $t, s$ are of minimum size.

Once we have chosen an equality-ambiguous pair of terms $t,s$ that is maximal with respect to this heuristic, if $t$ is of the form $f( t_1, \ldots t_n )$ and $s$ is of the form $f( s_1 \ldots s_n)$, we chose subterms $t_i', s_i'$ of arguments $t_i, s_i$ such that $M \not\models ( t_i' = s_i' )$ and $t_i'$ and $s_i'$ share a common prefix in $t_i$ and $s_i$ that is maximized.
We then chose to split our search by exploring both $t_i' = s_i'$ and $t_i' \neq s_i'$.
For example, if we have the equality-ambiguous pair $f( g( e ), e ), f( g( a ), g( b ) )$, we will chose to explore $e = a$ and $e \neq a$ in the case that $M \not\models e = a$.
We call the terms $t_i', s_i'$ the \emph{maximum depth ambiguity for $t, s$}.
%The maximum depth ambiguity for the equality-ambiguous pair $e, s$ is simply $e = s$.

If we chose the equality-ambiguous pair of terms $t,s$ such that $t$ is an instantiation constant, if $s$ is concrete, we split on $t = s$.
If $s$ contains instantiation constants, then we split on $t = c$ for a fresh constant $c$.

Formally, we define a total ordering $\succeq$ between equality-ambiguous pairs of terms, where $t,s \succeq t',s'$ in $M$ if $t,s$ satisfy a higher lexical combination than $t',s'$ of the following properties in descending order of importance:  \\
(P1) $M \not\models_T (t \neq s)$, \\
(P2) $t$ is not an instantiation constant, \\ 
(P3) $M \models_T (t = s)$, \\
(P4) $s$ is a concrete ground term, or \\
if $t,s$ and $t',s'$ satisfy the same subset of (P1)-(P4), then $t,s \succeq t',s'$ if and only if $t,s$ is greater according to the following metric in descending order of importance: \\
(N1) (minimum) value of $NArgs'( t, s )$, \\
(N2) (minimum) maximum of the number of symbols in of $s$ and $t$. \\

We are now ready to define the following search procedure $\rightarrow_{eamb}$ that is based on resolving equality-ambiguous pairs of terms in a state $M$: \\

Say $t, s$ are maximum with respect to $\succeq$ in $M$.
If $t$ is not an instantiation-constant, then $M \rightarrow_{eamb} M'$ if and only if $M' = M, (\neg)(t_i' = s_i')$, where $t_i', s_i'$ is the maximum depth ambiguity of terms $t, s$.
Otherwise, if $t$ is an instantiation constant such that $M \models t = s$, then $M \rightarrow_{eamb} M'$ if and only if $M' = M, (t = c)$ for fresh constant $c$. \\

We define the following termination condition $P_{1,3}$: \\

Say $t, s$ are maximum with respect to $\succeq$ in $M$.
$P_{1,3}(M)$ holds if and only if $t, s$ satisify at least a higher lexical combination than \{ (P1), (P3) \}. \\

Note that $\rightarrow_{eamb}$ is logically complete and terminating for quantifier instantiation with respect to $P_{1,3}$.

\begin{comment}
\begin{thm}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, if $M \rightarrow_{eamb} M'$ and $M'$ is non-terminal for quantifier instantiation with respect to $P_{eind}$, then there exists a pair of equality-ambiguous terms $t, s$ that are maximum with respect to $\succeq$.  
Futhermore, either $t$ is not an instantiation-constant, or $t$ and $s$ are instantiation constants such that $M \models t = s$.
\end{thm}
\begin{proof}
Say $M'$ is non-terminal for quantifier instantiation with respect to $P_{eind}$.
Therefore, all quantified formula $\psi_i \in M'$ are not instantiation-ready and there exists $e_i \in M$ for each $\psi_i$ that $M \not\models (e_i = s_i)$ for any concrete ground term $s_i$. 

Assume by contradiction that $t$ is an instantiation constant and $s$ is not an instantiation constant such that $M \models t = s$.
By our ordering, there does not exist a non-instantiation constant term $t'$ that is equality-ambiguous with any other term $s'$.
Since $P_{EUF}$ does not hold, there exists at least one term $t''$ such that 

In particular, this means that our unsolved constants $e_i$ do not exist as proper subterms of any term $t'$.
Therefore, since each $e_i$ is in $M$, it must be the case that either $M \models e_i \neq t''$ for some term $t''$ or $M \models e_i = t_e$ for some non-concrete term $t_e$.
\end{proof}
\end{comment}

\paragraph{Implementation}

We require an efficient method for computing $P_{1,3}(M)$ as well as finding a pair $t, s$ that is maximum with respect to $\succeq$ in $M$.
[do this] \\


{\bf Example 3, Continued}
Given the set of clauses $S = \{ (\psi :)\forall x. (f( x ) = x) \wedge f( f( a ) ) \neq a \}$, say we reach the DPLL(T) state $f( f( a ) ) \neq a, \psi, \neg (\bot^{\neg \psi})^d, f(e) \neq e \parallel (S':)S \cup \{ ( \neg \psi \vee \bot^{\neg \psi } \vee f( e ) \neq e ) \}$.
Our maximum pair of equality-ambiguous terms is $f( e ), f( f( a ) )$ and our maximum depth ambiguity is $e = f( a )$.
Searching the branch $e = f( a )$ leads us to a state in which $\psi$ is instantiation-ready with the instantiation $[f(a)/x]$ and $e \neq f( a )$ leads us to a state in which $f( e )$ is equality-independent.
Our search has thus calculated the set $\{ [f(a)/x] \}$.

By applying this instantiation, we obtain the clause $( \neg \psi \vee f( f( a ) ) = f( a ) )$, and after unit propagation we are in the state $f( f( a ) ) \neq a, \psi, \neg (\bot^{\neg \psi})^d, f(e) \neq e, f( f( a ) ) = f( a ) \parallel S'$.
Again, $\psi$ is not instantiation-ready, and we may chose to perform another round of instantiation.

Our maximum pair of equality-ambiguous terms is $f( e ), f( a )$ and our maximum depth ambiguity is $e = a$.
Searching the branch $e = a$ leads us to a state in which $\psi$ is instantiation-ready with the instantiation $[a/x]$.
Otherwise, searching the branch $e \neq a$ leads us to state where we again will split on $e = f( a )$.
In the branch $e = f( a )$, we get the theory conflict $e = f( a ), f( f( a ) ) = f( a ), f( e ) \neq e \models \bot$.
In the branch $e \neq f( a )$, we have that $f( e )$ is equality-independent.
Our search has thus calculated the set $\{ [a/x] \}$ and after adding the instantiation clause $( \neg \psi \vee f( a ) = a )$, the solver answers UNSAT. \\

In the previous example, we have found the relavant instantiations $[f(a)/x]$ and $[a/x]$, which has led us to contradict the ground clause $f( f( a ) ) \neq a$.
This was accomplished by using splitting lemmas to explore our search space, and identifying cases in which we can generate unsatisfiable instantiation clauses. \\

{\bf Example 4}
Consider the set of clauses $S = \{ (\psi_1 :)\forall x. f(x) \neq a, (\psi_2 :)\forall y. f(y) = a \}$.
After applying unit propagation twice, Counterexample $\forall$-Inst twice, after unit propagation we arrive in the DPLL(T) state $\psi_1, \psi_2,$ $\neg (\bot^{\neg \psi_1})^d, \neg (\bot^{\neg \psi_2})^d,$ $f(e_1) = a, f(e_2) \neq a \parallel S'$.
Let us say we decide to perform quantifier instantiation.
We add the splitting lemma $( e_1 = e_2 \vee e_1 \neq e_2 )$, and after deciding on $e_1 = e_2$, we have that our maximum pair of equality-ambiguous terms is $e_1$ and $e_2$.
We explore the branch $e_1 = c$ for fresh constant $c$, and after deciding on $e_1 = c$, we have that $\psi_1$ and $\psi_2$ are both instantiation ready with instantiations $[c/x]$ and $[c/y]$.
In the branch where $e_1 \neq e_2$, both $f( e_1 )$ and $f( e_2 )$ are equality-independent.
Our search has computed the set $\{ [c/x], [c/y] \}$.

After applying the instantiations $\psi_1[c/x]$ and $\psi_2[c/x]$ we obtain the conflict $f( c ) = a, f( c ) \neq a \models \bot$, and the solver will answer UNSAT. \\

\begin{comment}
Let us now focus our attention to identifying cases in which we can show there \emph{does not} exist instantiations for $\psi$ that lead to conflicts.
By the following lemma, we need only consider the case when all formulas $\psi \in M$ are disequality-compatible in $M$:

\begin{lemma}
For all contexts $M$, there exists a $M'$ such that $M' \models M$, and for all quantified formulas $\psi \in M$, $\psi$ is either equality-compatible or disequality-compatible in $M'$.
\end{lemma}
\begin{proof}
The aforementioned method (as demonstrated in Examples 5 and 6) can be thought of as a constructive proof of this lemma.
For each $\psi$, we split on equalities until all terms $t \mapsto^I \psi$ are equality-compatible, or there exists a term $t \mapsto^I \psi$ such that $t$ is disequality-compatible.
Note that by induction, all instantiation constants $e \mapsto^I \psi$ in $M$ are in non-singleton equivalence classes.
If the equivalence class of $e$ contains no concrete terms, we may introduce a fresh constant $c$ and add this to the equivalence class of $e$ via the splitting lemma $( e = c \vee e \neq c )$.
\end{proof}

\begin{lemma}
Given a consistent set of assertions $M$, if $t \mapsto^I \psi$ is disequality-compatible in $M$, then $M \not\models t[\varepsilon(\bar{e})/\bar{e}] = s'$ for any ground term $s'$.
\end{lemma}
\begin{proof}

\end{proof}

We can claim the following theorem, by noting that the property of term being disequality-compatible gives us the ability to construct a well formed model for quantified formulas.

\begin{thm}
Given a DPLL(T) state $M \parallel F$ where all clauses $F$ are satisfied, say for all asserted formula $(\psi :) \forall \bar{x}. \varphi(\bar{x} )$.
Then, if all quantified formulae $\psi \in M$ are disequality-compatible, then

\end{thm}
\begin{proof}

\end{proof}



The following example shows use of this theorem:

{\bf Example 6}
Say we wish to determine the satisfiability of the set of formulas $S = \{ a \neq b, f( a ) \neq d, (\psi :) \forall \bar{x}. (x = b \Rightarrow f( x ) = d) \}$.
After applying Unit propagation, applying Decide for $\bot^{\neg \psi}$, applying Counterexample $\forall$-Inst, after unit propagation we arrive in the DPLL(T) state $a \neq b, f( a ) \neq d, \neg( \bot^{\neg \psi} )^d, e = b, f( e ) \neq d \parallel S$.
Note that $f( e )$ is disequality combatible since $e \neq a$.
Therefore, by our theorem, $S$ is a satisifiable. \\
\end{comment}

\subsection{$Match_{LRA}$}

We assume a theory solver for $LRA$ which maintains a set of inequalities of the form:

\begin{tabular}{rl}
 & $\displaystyle\sum\limits_{i=0}^n C_{i1} \cdot a_i \geq 0$ \\
 & $\vdots$ \\
 & $\displaystyle\sum\limits_{i=0}^n C_{ij} \cdot a_i \geq 0$ \\
 $\displaystyle\sum\limits_{i=0}^m E_{i1} \cdot e_i +$ & $\displaystyle\sum\limits_{i=0}^n D_{i1} \cdot a_i \geq 0$ \\
 & $\vdots$ \\
 $\displaystyle\sum\limits_{i=0}^m E_{ik} \cdot e_i +$ & $\displaystyle\sum\limits_{i=0}^n D_{ik} \cdot a_i \geq 0$ \\
 \end{tabular} \\

where $a_1 \ldots a_n$ are ground constants of type $Real$ and $e_1 \ldots e_m$ are instantiation constants of type $Real$.

[do this]

\subsection{$Match_{IDT}$}

\subsection{$Match_{T}$ for Combined Theories $T$}

\section{Strategies for Searching}

In section~\ref{dpll-ce-lit}, we described an approach for handling quantifiers using counterexample literals.
Among the benefits of this approach was recognizing cases when quantified formulas $\forall \bar{x}. \varphi( \bar{x} )$ are valid, thus signalling that they do not need to be instantiated further.
In the case that all clauses are satisified and all universally quantified assertions are found to be valid, the solver can answer SAT.

Section~\ref{sec:theory-matching} focused primarily on the opposite goal: we described methods for finding relevant instantiations that are likely to falsify the current state.
After (ideally a small number of) instantatiations of the form $\varphi( \bar{c_1} ) \ldots \varphi( \bar{c_n} )$, we hope to find a state where a ground clause or a clause produced by these instantiations is falsified.
If this state contains no decision literals, we may answer UNSAT.

In this section, we will consider how to proceed in states where a quantified formula $\forall \bar{x}. \varphi( \bar{x} )$ is neither valid nor easily shown to be unsatisfiable. \\

{\bf Example 7} 
Say we wish to determine the satisfiability of the set of formulas $S = \{ a = b, (\psi :) \forall x. ((f(x) = c \vee x = a) \Rightarrow x = b) \}$.
After applying Unit Propagation twice, applying Decide on $\neg (\bot^{ \neg \psi })^d$, and applying Counterexample $\forall$-Inst, we obtain the clauses $( \neg \psi \vee \bot^{ \neg \psi } \vee f(e) = c \vee e = a )$ and $( \neg \psi \vee \bot^{ \neg \psi } \vee e \neq b )$.
After unit propagation in the second clause, we obtain $( e \neq b )$.
Now, in the first clause, the solver has a choice which literal to apply Decide to.
Say for the sake of argument we have that the solver chooses to assert $( f(e) = c )^d$.
Here we know that our counterexample must be such that $f( e ) = c$ and $e \neq b$.
We could suggest possible instantiations for $x$, but these may be fruitless since $e$ is somewhat unconstrained.
However, if we had decided instead to assert $( e = a )^d$, we would immediately have discovered a theory conflict, thus determining that $\psi$ is valid and returning SAT. \\

The previous example illustrates the importance of exploring multiple partial truth assignments for literals involving instantiation constants.
We will formalize a fair search strategy that is capable of reasoning about all possible variations of how counterexamples to universal formulas may look.

\subsection{Enumerating Decisions on Literals with Instantiation Constants}

[do this]

\section{Recognizing Other SAT Instances}

[this section needs work]

\subsection{Decidable Fragments in SMT}

Some approaches to SMT with quantifiers rely on \emph{complete instantiation}, that is, recognizing when a quantified formula $\forall \bar{ x }. \varphi( \bar{ x } )$ is a part of a \emph{deciable fragment} of first order logic.
In some cases, a set of ground terms $t_1 \ldots t_n$ is sufficient for instantiating $\forall \bar{ x }. \varphi( \bar{ x } )$, and in the case that $\varphi( \bar{ t_1 } ) \wedge \ldots \wedge \varphi( \bar{ t_n } )$ is satisfiable, then $\forall \bar{ x }. \varphi( \bar{ x } )$ can be considered valid.

This section describes methods for recognizing other cases where only a finite number of instantiations need be applied to a particular formula $\forall \bar{ x }. \varphi( \bar{ x } )$ \emph{within a context $M$}.
These cases are made possible by realizing that in a DPLL(T) state $M \parallel F$, the instantiations required for $\forall \bar{ x }. \varphi( \bar{ x } )$ is dependent upon our current assertions $M$.
%In cases where only a finite number of instantiations need be applied to $(\psi:) \forall \bar{ x }. \varphi( \bar{ x } )$ in a particular context $M$, we will say $\psi$ is decidable in $M$.  [formalize this in a better way?]

\section{Alternative Implementations}
\label{sec:implementation}

This document has outlined the following suggestions (A1)-(A2) and requirement (A3) for the DPLL(T) solver: \\

\noindent (A1) $(\bot^{\neg \psi})^d$ should never be asserted, \\
(A2) $\neg (\bot^{\neg \psi})^d$ should be asserted immediately after $\psi^{(d)}$ is asserted and only in such cases, and \\
(A3) if $\psi^{(d)}$ is not asserted, then no literal $l$ where $l \mapsto^I \psi$ can be asserted. \\

Ideally, the internal strategies of the SAT-solver should not have to be modified to enforce this schema.
For this reason, we may employ the following alternative recommendations, for which (A1), (A2) and (A3) hold as a consequence.

\subsection{Via Clause Forgetting}

\noindent (B1) For a quantified formula $\psi$, maintain a set $S^\psi$ of all lemmas $C_1, \ldots C_n$ added to $F$ for which $C_i \mapsto^I \psi$, $1 \leq i \leq n$, \\
(B2) When $\psi^{(d)}$ is asserted to $M$, first assert $\neg (\bot^{\neg \psi})^d$ and then add all lemmas $S^\psi$ to $F$, \\
(B3) When $\psi^{(d)}$ removed from $M$, remove each of $S^\psi$ from $F$. \\

Note that (B2) consists of applying Decide (twice) and $n$ applications of $T$-Learn, and (B3) consists of $n$ applications of $T$-Forget.
We know that each of these steps can be executed if we add each lemma in the same order/remove each lemma in the reverse order as it was learned.

This gives us the following improved invariant: \\

{\bf Invariant 1 (Revised)}:
For all DPLL(T) states $M \parallel F$,
(a) all instances of counterexample literals $\bot^{\neg \psi}$ in $F$ reside in clauses of the form $( \neg \psi \vee \bot^{\neg \psi} \vee C(\bar{e}) )$ where if $C(e)$ is unsatisifiable, then $\psi$ is valid, and
(b) if $\psi^{(d)} \not\in M$, then $F$ contains no counterexample literals or literals $l$ such that $l \mapsto^I \psi$. \\

We have that (A1) holds since by Invariant 1(b) (Revised), $\bot^{\neg \psi}$ will only occur in $F$ when $\psi^{(d)}$ is asserted in $M$, and by (B2), only after $\neg (\bot^{\neg \psi})^d$ is asserted.
We have that (A2) holds by (B2) and using similar reasoning.
We have that (A3) also holds similarly to (A1) by noting that literals $l$ such that $l \mapsto^I \psi$ only occur in $F$ when $\psi^{(d)}$ is asserted in $M$.

This implementation scheme requires the ability to remove clauses from the SAT-solver database as well as a special instance of a forced decision.

\begin{comment}
\subsection{Via Controlling Decisions}

\noindent (C1) For a quantified formula $\psi$, maintain a set $L^\psi$ of literals $l_1, \ldots l_n, \bot^{\neg \psi} \in F$ such that $l_i \mapsto^I \psi$, $1 \leq i \leq n$, \\
(C2) When $\psi \not\in M$, mark literals, \\
(C3)
(C4) When $\psi^{(d)}$ is asserted to $M$, assert $\neg (\bot^{\neg \psi})^d$, \\
\end{comment}

\end{document}

